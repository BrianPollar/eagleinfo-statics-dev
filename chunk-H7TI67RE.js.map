{
  "version": 3,
  "sources": ["../../biz-nest/packages/auth/client/src/defines/refresh-token.define.ts", "../../biz-nest/packages/auth/client/src/auth-client.ts", "../../biz-nest/packages/auth/client/src/defines/user-ip.define.ts", "../../biz-nest/packages/auth/client/src/defines/user-login-attempt.define.ts", "../../biz-nest/packages/auth/client/src/defines/user-suspicious-activity.define.ts", "../../biz-nest/packages/auth/client/src/defines/user.define.ts", "../../biz-nest/packages/auth/client/src/utils/auth.ts"],
  "sourcesContent": ["import {\n  DatabaseAuto,\n  IbulkDelete,\n  IbulkDeleteSuccessResponse,\n  IdataArrayResponse,\n  IdatabaseAuto, IdeleteOneResponse, IfilterProps\n} from '@biz-nest/core-client';\nimport { lastValueFrom } from 'rxjs';\nimport { AuthClient } from '../auth-client';\n\n/**\n * Represents a persisted refresh token record returned by the Auth service.\n *\n * Includes the token string, its owner, expiry, user agent and IP metadata,\n * lifecycle flags (revocation and replacement), creation/update timestamps,\n * and the logical scope this token is valid for.\n *\n * @public\n */\nexport interface IrefreshToken\n  extends IdatabaseAuto {\n\n  /** The user that owns this refresh token. */\n  user: string;\n\n  /** The opaque refresh token string. */\n  token: string;\n\n  /** Absolute expiration date/time of the token. */\n  expiresAt: Date;\n\n  /** Optional user agent captured when the token was issued. */\n  userAgent?: string;\n\n  /** Optional IP address captured when the token was issued. */\n  ipAddress?: string;\n\n  /** Whether the token has been revoked server-side. */\n  isRevoked?: boolean;\n\n  /** If replaced, contains the successor token string. */\n  replacedByToken?: string;\n\n  /** The creation timestamp. */\n  createdAt: Date;\n\n  /** The last update timestamp. */\n  updatedAt: Date;\n\n  /** Logical scope for which the token is valid (e.g., \"web\", \"mobile\"). */\n  tokenScope: string;\n\n  /** Default number of days before expiry, if provided by the server. */\n  tokenDefaultDays?: number;\n\n  /** User info of the user that owns this refresh token. */\n  userInfo: {\n    firstName: string;\n    lastName: string;\n    email: string;\n    phone: string;\n  };\n}\n\n\n/**\n * Client-side model for interacting with the Refresh Token API.\n *\n * Provides typed helpers to list, filter, fetch, bulk delete, and remove\n * refresh tokens. Each instance wraps a single refresh-token document.\n *\n * @public\n * @remarks\n * This is the raw DTO shape as returned by the API. Prefer using the\n * {@link RefreshToken} class when invoking client operations.\n *\n * @example\n * ```typescript\n * const result = await RefreshToken.getAll();\n *\n * const result = await RefreshToken.filterAll({\n *   // filter criteria\n * });\n *\n * const result = await RefreshToken.bulkDelete({\n *   // delete criteria\n * });\n *\n * const refreshToken = await RefreshToken.getOne('resourceId');\n *\n * const result = await RefreshToken.remove();\n * ```\n */\n\nexport class RefreshToken\n  extends DatabaseAuto {\n  /** Base path for refresh token routes. */\n  private static readonly baseUrl = '/refresh-token';\n\n  /** User that owns this refresh token. */\n  readonly user: string;\n\n  /** Opaque refresh token string. */\n  readonly token: IrefreshToken['token'];\n\n  /** Absolute expiration date/time of the token. */\n  readonly expiresAt: IrefreshToken['expiresAt'];\n\n  /** Optional user agent captured when the token was issued. */\n  readonly userAgent?: IrefreshToken['userAgent'];\n\n  /** Optional IP address captured when the token was issued. */\n  readonly ipAddress?: IrefreshToken['ipAddress'];\n\n  /** Whether the token has been revoked server-side. */\n  readonly isRevoked?: IrefreshToken['isRevoked'];\n\n  /** If replaced, contains the successor token string. */\n  readonly replacedByToken?: IrefreshToken['replacedByToken'];\n\n  /** Logical scope for which the token is valid. */\n  readonly tokenScope: IrefreshToken['tokenScope'];\n\n  /** Default number of days before expiry, if provided by the server. */\n  readonly tokenDefaultDays?: IrefreshToken['tokenDefaultDays'];\n\n  /** User info of the user that owns this refresh token. */\n  readonly userInfo: IrefreshToken['userInfo'];\n\n\n  /**\n   * Constructs an instance of {@link RefreshToken}.\n   *\n   * @param data - The refresh-token data used to initialize the instance.\n   */\n  constructor(data: IrefreshToken) {\n    super(data);\n\n    this.user = data.user;\n    this.token = data.token;\n    this.expiresAt = new Date(data.expiresAt);\n    this.userAgent = data.userAgent;\n    this.ipAddress = data.ipAddress;\n    this.isRevoked = data.isRevoked;\n    this.replacedByToken = data.replacedByToken;\n    this.tokenScope = data.tokenScope;\n    this.tokenDefaultDays = data.tokenDefaultDays;\n    this.userInfo = data.userInfo;\n  }\n\n  /**\n   * Retrieves all refresh tokens with pagination support.\n   *\n   * @param offset - The starting point for pagination. Defaults to `0`.\n   * @param limit - The number of items to retrieve. Defaults to `20`.\n   * @returns A promise that resolves to the total count and an array of\n   * {@link RefreshToken} instances.\n   */\n  static async getAll(offset = 0, limit = 20) {\n    const query = new URLSearchParams({\n      offset: offset.toString(),\n      limit: limit.toString()\n    }).toString();\n    const observer$ = AuthClient.ehttp\n      .makeGet<IdataArrayResponse<IrefreshToken>>(`${RefreshToken.baseUrl}?${query}`);\n    const refreshTokens = await lastValueFrom(observer$);\n\n    return {\n      count: refreshTokens.count,\n      dataArr: refreshTokens.data.map((val) => new RefreshToken(val))\n    };\n  }\n\n  /**\n   * Filters refresh tokens based on the provided filter properties.\n   *\n   * @param filter - The filter criteria for retrieving refresh tokens.\n   * @returns A promise that resolves to the total count and an array of\n   * {@link RefreshToken} instances that match the filter.\n   */\n  static async filterAll(filter: IfilterProps) {\n    const observer$ = AuthClient.ehttp\n      .makePost<IdataArrayResponse<IrefreshToken>>(`${RefreshToken.baseUrl}/filter`, filter);\n    const refreshTokens = await lastValueFrom(observer$);\n\n    return {\n      count: refreshTokens.count,\n      dataArr: refreshTokens.data.map((val) => new RefreshToken(val))\n    };\n  }\n\n  /**\n   * Retrieves a single refresh token by resource identifier.\n   *\n   * @param resourceId - The unique identifier for the refresh token to retrieve.\n   * @returns A promise that resolves to the {@link RefreshToken} instance.\n   */\n  static async getOne(resourceId: string) {\n    const observer$ = AuthClient.ehttp\n      .makeGet<IrefreshToken>(`${RefreshToken.baseUrl}/${resourceId}`);\n    const refreshToken = await lastValueFrom(observer$);\n\n    return new RefreshToken(refreshToken);\n  }\n\n  /**\n   * Removes multiple refresh tokens based on the provided criteria.\n   *\n   * @param payload - The criteria for deleting multiple refresh tokens.\n   * @returns A promise that resolves to the bulk delete operation result.\n   */\n  static bulkDelete(payload: IbulkDelete) {\n    const observer$ = AuthClient.ehttp\n      .makePost<IbulkDeleteSuccessResponse>(`${RefreshToken.baseUrl}/bulk-delete`, payload);\n\n    return lastValueFrom(observer$);\n  }\n\n  /**\n   * Revokes the current refresh token instance.\n   *\n   * @returns A promise that resolves to the delete operation result, or `null`.\n   */\n  revoke() {\n    const observer$ = AuthClient.ehttp\n      .makePost<IdeleteOneResponse | null>(`${RefreshToken.baseUrl}/revoke`, { _id: this._id });\n\n    return lastValueFrom(observer$);\n  }\n\n  /**\n   * Removes the current refresh token instance.\n   *\n   * @returns A promise that resolves to the delete operation result, or `null`.\n   */\n  remove() {\n    const observer$ = AuthClient.ehttp\n      .makeDelete<IdeleteOneResponse | null>(`${RefreshToken.baseUrl}/${this._id}`);\n\n    return lastValueFrom(observer$);\n  }\n}\n", "import {\n  BizNestClientError, EhttpController, FrontendLogger, IehttpControllerConfig\n} from '@biz-nest/core-client';\n\n/**\n * Social login endpoints exposed by the backend for client-initiated OAuth flows.\n *\n * @public\n */\nexport interface IsocialCallUrls {\n\n  /** OAuth entrypoint for Google login. */\n  google: string;\n\n  /** OAuth entrypoint for Facebook login. */\n  facebook: string;\n}\n\n/**\n * Thin wrapper around {@link EhttpController} to manage Auth API calls and\n * optional social login URLs. Must be initialized once per app session.\n *\n * @public\n */\nexport class AuthClient {\n  private static http: EhttpController;\n  private static localSocialCallUrls?: IsocialCallUrls;\n\n  /**\n   * Creates an instance of {@link AuthClient} with environment validation.\n   *\n   * @param config - Configuration passed to the underlying {@link EhttpController}.\n   * @param socialCallUrls - Optional social login URLs (Google/Facebook).\n   * @throws {@link BizNestClientError} If configuration is invalid.\n   */\n  constructor(config: IehttpControllerConfig, socialCallUrls?: IsocialCallUrls) {\n    if (!config || typeof config !== 'object') {\n      throw new BizNestClientError('config must be a valid object');\n    }\n\n\n    FrontendLogger.debug('AuthClient initialized');\n    AuthClient.http = new EhttpController(config);\n    AuthClient.localSocialCallUrls = socialCallUrls;\n  }\n\n  /**\n   * Provides the initialized HTTP controller.\n   *\n   * @returns The singleton {@link EhttpController} instance.\n   * @throws {@link BizNestClientError} If the client has not been initialized via constructor.\n   */\n  static get ehttp() {\n    if (!AuthClient.http) {\n      throw new BizNestClientError('HTTP client not initialized. Call new AuthClient.');\n    }\n\n    return AuthClient.http;\n  }\n\n  /**\n * Provides configured social login endpoints.\n *\n * @returns Social OAuth entrypoints for Google and Facebook.\n * @throws {@link BizNestClientError} If social URLs were not provided at construction.\n */\n  static get socialCallUrls() {\n    if (!AuthClient.localSocialCallUrls) {\n      throw new BizNestClientError('Social call URLs not provided at construction..');\n    }\n\n    return AuthClient.localSocialCallUrls;\n  }\n}\n", "import {\n  DatabaseAuto,\n  IbulkDelete,\n  IbulkDeleteSuccessResponse,\n  IdataArrayResponse,\n  IdatabaseAuto,\n  IdeleteOneResponse,\n  IfilterProps, Iuser,\n  IuserIpAnalytics\n} from '@biz-nest/core-client';\nimport { lastValueFrom } from 'rxjs';\nimport { AuthClient } from '../auth-client';\n\n/**\n * Represents IP reputation and status metadata tracked for a user.\n *\n * Includes whitelisted (green), suspicious (red), and unverified IP lists,\n * plus a blocking state tied to login attempts.\n *\n * @public\n */\nexport interface IuserIp\n  extends IdatabaseAuto {\n\n  /** Unique identifier of this user-IP record. */\n  _id: string;\n\n  /** The user this IP metadata belongs to. */\n  user: Iuser;\n\n  /** Known safe IP addresses for the user. */\n  greenIps: string[];\n\n  /** Known risky or flagged IP addresses for the user. */\n  redIps: string[];\n\n  /** IP addresses seen but not yet verified. */\n  unverifiedIps: string[];\n\n  /**\n   * Block state details.\n   * - status: Whether the user is currently blocked.\n   * - loginAttemptRef: Reference to the triggering attempt/event.\n   * - timesBlocked: Number of times the user has been blocked.\n   */\n  blocked: {\n      status: boolean;\n      loginAttemptRef: string;\n      timesBlocked: number;\n    };\n}\n\n/**\n * Client-side model for interacting with the User IP API.\n *\n * Provides helpers to fetch, filter, update, and delete user IP records,\n * as well as to retrieve analytics for reporting/monitoring.\n *\n * @public\n * @remarks\n * This is the raw DTO shape as returned by the API. Prefer using the\n * {@link UserIp} class when invoking client operations.\n *\n * @example\n * ```typescript\n * const result = await UserIp.getAll();\n *\n * const result = await UserIp.filterAll({\n *   // filter criteria\n * });\n *\n * const result = await UserIp.bulkDelete({\n *   // delete criteria\n * });\n *\n * const userIp = await UserIp.getOne('resourceId');\n *\n * const result = await UserIp.remove();\n * ```\n */\n\nexport class UserIp\n  extends DatabaseAuto {\n  /** Base path for user IP routes. */\n  private static readonly baseUrl = '/user-ip';\n\n  /** The user this IP metadata belongs to. */\n  readonly user: IuserIp['user'];\n\n  /** Known safe IP addresses for the user. */\n  readonly greenIps: IuserIp['greenIps'];\n\n  /** Known risky or flagged IP addresses for the user. */\n  readonly redIps: IuserIp['redIps'];\n\n  /** IP addresses seen but not yet verified. */\n  readonly unverifiedIps: IuserIp['unverifiedIps'];\n\n  /** Current block state details. */\n  readonly blocked: IuserIp['blocked'];\n\n  /**\n   * Constructs an instance of {@link UserIp}.\n   *\n   * @param data - The user IP data used to initialize the instance.\n   */\n  constructor(data: IuserIp) {\n    super(data);\n\n    this.user = data.user;\n    this.greenIps = data.greenIps;\n    this.redIps = data.redIps;\n    this.unverifiedIps = data.unverifiedIps;\n    this.blocked = data.blocked;\n  }\n\n  /**\n   * Retrieves analytics related to user IP data.\n   *\n   * @param filter - Filter criteria to compute analytics on a subset of records.\n   * @returns A promise that resolves to the computed user IP analytics.\n   */\n  static getUserIpAnalytics(filter: IfilterProps) {\n    const observer$ = AuthClient.ehttp\n      .makePost<IuserIpAnalytics>(`${UserIp.baseUrl}/analytics`, filter);\n\n    return lastValueFrom(observer$);\n  }\n\n  /**\n   * Retrieves all user IPs with pagination support.\n   *\n   * @param offset - The starting point for pagination. Defaults to `0`.\n   * @param limit - The number of items to retrieve. Defaults to `20`.\n   * @returns A promise that resolves to the total count and an array of\n   * {@link UserIp} instances.\n   */\n  static async getAll(offset = 0, limit = 20) {\n    const query = new URLSearchParams({\n      offset: offset.toString(),\n      limit: limit.toString()\n    }).toString();\n    const observer$ = AuthClient.ehttp\n      .makeGet<IdataArrayResponse<IuserIp>>(`${UserIp.baseUrl}?${query}`);\n    const userIps = await lastValueFrom(observer$);\n\n    return {\n      count: userIps.count,\n      dataArr: userIps.data.map((val) => new UserIp(val))\n    };\n  }\n\n  /**\n   * Filters user IPs based on the provided filter properties.\n   *\n   * @param filter - The filter criteria for retrieving user IP records.\n   * @returns A promise that resolves to the total count and an array of\n   * {@link UserIp} instances matching the filter.\n   */\n  static async filterAll(filter: IfilterProps) {\n    const observer$ = AuthClient.ehttp\n      .makePost<IdataArrayResponse<IuserIp>>(`${UserIp.baseUrl}/filter`, filter);\n    const userIps = await lastValueFrom(observer$);\n\n    return {\n      count: userIps.count,\n      dataArr: userIps.data.map((val) => new UserIp(val))\n    };\n  }\n\n  /**\n   * Retrieves a single user IP record by resource identifier.\n   *\n   * @param resourceId - The unique identifier for the user IP record to retrieve.\n   * @returns A promise that resolves to the {@link UserIp} instance.\n   */\n  static async getOne(resourceId: string) {\n    const observer$ = AuthClient.ehttp\n      .makeGet<IuserIp>(`${UserIp.baseUrl}/${resourceId}`);\n    const userip = await lastValueFrom(observer$);\n\n    return new UserIp(userip);\n  }\n\n  /**\n   * Removes multiple user IP records based on the provided criteria.\n   *\n   * @param payload - The criteria for deleting multiple user IPs.\n   * @returns A promise that resolves to the bulk delete operation result.\n   */\n  static bulkDelete(payload: IbulkDelete) {\n    const observer$ = AuthClient.ehttp\n      .makePost<IbulkDeleteSuccessResponse>(`${UserIp.baseUrl}/bulk-delete`, payload);\n\n    return lastValueFrom(observer$);\n  }\n\n  /**\n   * Updates the current user IP record with the provided data.\n   *\n   * @param payload - The fields to update on this user IP record.\n   * @returns A promise that resolves to the updated {@link UserIp} instance.\n   */\n  async update(payload: Partial<IuserIp>) {\n    const observer$ = AuthClient.ehttp\n      .makePut<IuserIp>(`${UserIp.baseUrl}/${this._id}`, payload);\n\n    return new UserIp(await lastValueFrom(observer$));\n  }\n\n\n  /**\n   * Removes the current user IP record.\n   *\n   * @returns A promise that resolves to the delete operation result, or `null`.\n   */\n  remove() {\n    const observer$ = AuthClient.ehttp\n      .makeDelete<IdeleteOneResponse | null>(`${UserIp.baseUrl}/${this._id}`);\n\n    return lastValueFrom(observer$);\n  }\n}\n", "import {\n  DatabaseAuto,\n  IbulkDelete,\n  IbulkDeleteSuccessResponse,\n  IdataArrayResponse,\n  IdatabaseAuto, IdeleteOneResponse, IfilterProps,\n  Iuser\n} from '@biz-nest/core-client';\nimport { lastValueFrom } from 'rxjs';\nimport { AuthClient } from '../auth-client';\n\n\nexport interface IloginAttempt\n  extends IdatabaseAuto {\n\n  /** The user who performed the login attempt. */\n  user: Iuser;\n\n  /** IP address from which the attempt originated. */\n  ip: string;\n\n  /** Whether the attempt succeeded (true) or failed (false). */\n  successful: boolean;\n}\n\n/**\n * Describes a single login attempt for a user, including the source IP\n * and whether the attempt was successful.\n *\n * @public\n * @remarks\n * This is the raw DTO shape as returned by the API. Prefer using the\n * {@link UserLoginAttempt} class when invoking client operations.\n *\n * @example\n * ```typescript\n * const result = await UserLoginAttempt.getAll();\n *\n * const result = await UserLoginAttempt.filterAll({\n *   // filter criteria\n * });\n *\n * const result = await UserLoginAttempt.bulkDelete({\n *   // delete criteria\n * });\n *\n * const loginAttempt = await UserLoginAttempt.getOne('resourceId');\n *\n * const result = await UserLoginAttempt.remove();\n * ```\n */\nexport class UserLoginAttempt\n  extends DatabaseAuto {\n  /** Base path for login attempt routes. */\n  private static readonly baseUrl = '/login-attempt';\n\n  /** The user who performed the login attempt. */\n  readonly user: IloginAttempt['user'];\n\n  /** IP address from which the attempt originated. */\n  readonly ip: IloginAttempt['ip'];\n\n  /** Whether the attempt succeeded (true) or failed (false). */\n  readonly successful: IloginAttempt['successful'];\n\n\n  /**\n   * Constructs an instance of {@link UserLoginAttempt}.\n   *\n   * @param data - The login-attempt data used to initialize the instance.\n   */\n  constructor(data: IloginAttempt) {\n    super(data);\n\n    this.user = data.user;\n    this.ip = data.ip;\n    this.successful = data.successful;\n  }\n\n  /**\n   * Retrieves all login attempts with pagination support.\n   *\n   * @param offset - The starting point for pagination. Defaults to `0`.\n   * @param limit - The number of items to retrieve. Defaults to `20`.\n   * @returns A promise that resolves to the total count and an array of\n   * {@link UserLoginAttempt} instances.\n   */\n  static async getAll(offset = 0, limit = 20) {\n    const query = new URLSearchParams({\n      offset: offset.toString(),\n      limit: limit.toString()\n    }).toString();\n    const observer$ = AuthClient.ehttp\n      .makeGet<IdataArrayResponse<IloginAttempt>>(`${UserLoginAttempt.baseUrl}?${query}`);\n    const loginAttempts = await lastValueFrom(observer$);\n\n    return {\n      count: loginAttempts.count,\n      dataArr: loginAttempts.data.map((val) => new UserLoginAttempt(val))\n    };\n  }\n\n  /**\n   * Filters login attempts based on the provided filter properties.\n   *\n   * @param filter - The filter criteria for retrieving login attempts.\n   * @returns A promise that resolves to the total count and an array of\n   * {@link UserLoginAttempt} instances that match the filter.\n   */\n  static async filterAll(filter: IfilterProps) {\n    const observer$ = AuthClient.ehttp\n      .makePost<IdataArrayResponse<IloginAttempt>>(`${UserLoginAttempt.baseUrl}/filter`, filter);\n    const loginAttempts = await lastValueFrom(observer$);\n\n    return {\n      count: loginAttempts.count,\n      dataArr: loginAttempts.data.map((val) => new UserLoginAttempt(val))\n    };\n  }\n\n  /**\n   * Retrieves a single login attempt by resource identifier.\n   *\n   * @param resourceId - The unique identifier for the login attempt to retrieve.\n   * @returns A promise that resolves to the {@link UserLoginAttempt} instance.\n   */\n  static async getOne(resourceId: string) {\n    const observer$ = AuthClient.ehttp\n      .makeGet<IloginAttempt>(`${UserLoginAttempt.baseUrl}/${resourceId}`);\n    const loginAttempt = await lastValueFrom(observer$);\n\n    return new UserLoginAttempt(loginAttempt);\n  }\n\n  /**\n   * Removes multiple login attempts based on the provided criteria.\n   *\n   * @param payload - The criteria for deleting multiple login attempts.\n   * @returns A promise that resolves to the bulk delete operation result.\n   */\n  static bulkDelete(payload: IbulkDelete) {\n    const observer$ = AuthClient.ehttp\n      .makePost<IbulkDeleteSuccessResponse>(`${UserLoginAttempt.baseUrl}/bulk-delete`, payload);\n\n    return lastValueFrom(observer$);\n  }\n\n  /**\n   * Removes the current login attempt.\n   *\n   * @returns A promise that resolves to the delete operation result, or `null`.\n   */\n  remove() {\n    const observer$ = AuthClient.ehttp\n      .makeDelete<IdeleteOneResponse | null>(`${UserLoginAttempt.baseUrl}/${this._id}`);\n\n    return lastValueFrom(observer$);\n  }\n}\n", "import {\n  DatabaseAuto,\n  IbulkDelete,\n  IbulkDeleteSuccessResponse,\n  IdataArrayResponse,\n  IdatabaseAuto, IdeleteOneResponse, IfilterProps,\n  Iuser\n} from '@biz-nest/core-client';\nimport { lastValueFrom } from 'rxjs';\nimport { AuthClient } from '../auth-client';\n\n/**\n * Describes a flagged user activity considered suspicious, capturing\n * the actor, originating IP, and the reason for the flag.\n *\n * @public\n */\nexport interface IsuspiciousActivity\n  extends IdatabaseAuto {\n\n  /** The user associated with the suspicious activity. */\n  user: Iuser;\n\n  /** IP address from which the suspicious activity originated. */\n  ip: string;\n\n  /** Reason explaining why the activity was flagged. */\n  reason: string;\n}\n\n/**\n * Client-side model for interacting with the Suspicious Activity API.\n *\n * Provides helpers to list, filter, fetch, and delete suspicious activity records.\n *\n * @public\n * @remarks\n * This is the raw DTO shape as returned by the API. Prefer using the\n * {@link UserSuspiciousActivity} class when invoking client operations.\n *\n * @example\n * ```typescript\n * const result = await UserSuspiciousActivity.getAll();\n *\n * const result = await UserSuspiciousActivity.filterAll({\n *   // filter criteria\n * });\n *\n * const result = await UserSuspiciousActivity.bulkDelete({\n *   // delete criteria\n * });\n *\n * const suspiciousActivity = await UserSuspiciousActivity.getOne('resourceId');\n *\n * const result = await UserSuspiciousActivity.remove();\n * ```\n */\nexport class UserSuspiciousActivity\n  extends DatabaseAuto {\n  /** Base path for suspicious activity routes. */\n  private static readonly baseUrl = '/suspicious-activity';\n\n  /** The user associated with the suspicious activity. */\n  readonly user: IsuspiciousActivity['user'];\n\n  /** IP address from which the suspicious activity originated. */\n  readonly ip: IsuspiciousActivity['ip'];\n\n  /** Reason explaining why the activity was flagged. */\n  readonly reason: IsuspiciousActivity['reason'];\n\n\n  /**\n   * Constructs an instance of {@link UserSuspiciousActivity}.\n   *\n   * @param data - The suspicious-activity data used to initialize the instance.\n   */\n  constructor(data: IsuspiciousActivity) {\n    super(data);\n\n    this.user = data.user;\n    this.ip = data.ip;\n    this.reason = data.reason;\n  }\n\n  /**\n   * Retrieves all suspicious activity items with pagination support.\n   *\n   * @param offset - The starting point for pagination. Defaults to `0`.\n   * @param limit - The number of items to retrieve. Defaults to `20`.\n   * @returns A promise that resolves to the total count and an array of\n   * {@link UserSuspiciousActivity} instances.\n   */\n  static async getAll(offset = 0, limit = 20) {\n    const query = new URLSearchParams({\n      offset: offset.toString(),\n      limit: limit.toString()\n    }).toString();\n    const observer$ = AuthClient.ehttp\n      .makeGet<IdataArrayResponse<IsuspiciousActivity>>(`${UserSuspiciousActivity.baseUrl}?${query}`);\n    const suspiciousActivities = await lastValueFrom(observer$);\n\n    return {\n      count: suspiciousActivities.count,\n      dataArr: suspiciousActivities.data.map((val) => new UserSuspiciousActivity(val))\n    };\n  }\n\n  /**\n   * Filters suspicious activity based on the provided filter properties.\n   *\n   * @param filter - The filter criteria for retrieving suspicious activity.\n   * @returns A promise that resolves to the total count and an array of\n   * {@link UserSuspiciousActivity} instances matching the filter.\n   */\n  static async filterAll(filter: IfilterProps) {\n    const observer$ = AuthClient.ehttp\n      .makePost<IdataArrayResponse<IsuspiciousActivity>>(`${UserSuspiciousActivity.baseUrl}/filter`, filter);\n    const suspiciousActivities = await lastValueFrom(observer$);\n\n    return {\n      count: suspiciousActivities.count,\n      dataArr: suspiciousActivities.data.map((val) => new UserSuspiciousActivity(val))\n    };\n  }\n\n  /**\n   * Retrieves a single suspicious activity item by resource identifier.\n   *\n   * @param resourceId - The unique identifier for the suspicious activity to retrieve.\n   * @returns A promise that resolves to the {@link UserSuspiciousActivity} instance.\n   */\n  static async getOne(resourceId: string) {\n    const observer$ = AuthClient.ehttp\n      .makeGet<IsuspiciousActivity>(`${UserSuspiciousActivity.baseUrl}/${resourceId}`);\n    const suspiciousActivity = await lastValueFrom(observer$);\n\n    return new UserSuspiciousActivity(suspiciousActivity);\n  }\n\n  /**\n   * Removes multiple suspicious activity items based on the provided criteria.\n   *\n   * @param payload - The criteria for deleting multiple suspicious activity items.\n   * @returns A promise that resolves to the bulk delete operation result.\n   */\n  static bulkDelete(payload: IbulkDelete) {\n    const observer$ = AuthClient.ehttp\n      .makePost<IbulkDeleteSuccessResponse>(`${UserSuspiciousActivity.baseUrl}/bulk-delete`, payload);\n\n    return lastValueFrom(observer$);\n  }\n\n  /**\n   * Removes the current suspicious activity item.\n   *\n   * @returns A promise that resolves to the delete operation result, or `null`.\n   */\n  remove() {\n    const observer$ = AuthClient.ehttp\n      .makeDelete<IdeleteOneResponse | null>(`${UserSuspiciousActivity.baseUrl}/${this._id}`);\n\n    return lastValueFrom(observer$);\n  }\n}\n", "import {\n  DatabaseAuto, IdataArrayResponse, Ifile, IfilterProps, Iuser, TuserRequest, validateData\n} from '@biz-nest/core-client';\nimport { lastValueFrom } from 'rxjs';\nimport { AuthClient } from '../auth-client';\n\n/**\n * Alias for the User data transfer object as returned by the Auth service.\n *\n * @public\n */\nexport type TuserProps = Iuser;\n\n/**\n * Client-side model representing an authenticated user and exposing\n * helper methods to query, filter, update, and upload profile media.\n *\n * @public\n * @remarks\n * This is the raw DTO shape as returned by the API. Prefer using the\n * {@link User} class when invoking client operations.\n *\n * @example\n * ```typescript\n * // Get all users with pagination\n * const { count, dataArr: users } = await User.getAll(0, 10);\n *\n * // Filter users by criteria\n * const filteredUsers = await User.filterAll({\n *   where: {\n *     email: { $regex: 'example.com', $options: 'i' },\n *     verified: true\n *   },\n *   sort: { createdAt: -1 }\n * });\n *\n * // Get a single user by ID\n * const user = await User.getOne('user123');\n *\n * // Update user profile\n * const updatedUser = await user.updateProfile({\n *   firstName: 'John',\n *   lastName: 'Doe',\n *   phone: '+1234567890'\n * });\n *\n * // Upload profile picture\n * const fileInput = document.querySelector('input[type=\"file\"]');\n * const file = fileInput.files[0];\n * await user.uploadProfilePicture(file);\n *\n * // Delete user images\n * await user.deleteImages(['image123', 'image456']);\n *\n * // Static method to update a user by ID\n * const updatedUser = await User.updateOne('user123', {\n *   firstName: 'Jane',\n *   lastName: 'Smith'\n * });\n *\n * // Delete a user by ID\n * await User.remove('user123');\n *\n * ```\n */\n\nexport class User extends DatabaseAuto {\n  private static readonly baseUrl = '/user';\n  readonly urId: TuserProps['urId'];\n  readonly firstName: TuserProps['firstName'];\n  readonly lastName: TuserProps['lastName'];\n  readonly email: TuserProps['email'];\n  readonly profilePicture?: TuserProps['profilePicture'];\n  readonly profileCoverPicture?: TuserProps['profileCoverPicture'];\n  readonly phone: TuserProps['phone'];\n  readonly online: TuserProps['online'];\n  readonly verified?: TuserProps['verified'];\n  readonly socialAuthFrameworks?: TuserProps['socialAuthFrameworks'];\n  readonly phoneVerificationMeta?: TuserProps['phoneVerificationMeta'];\n  readonly emailVerificationMeta?: TuserProps['emailVerificationMeta'];\n  readonly recoveryPhoneNumbers?: TuserProps['recoveryPhoneNumbers'];\n  readonly recoveryEmails?: TuserProps['recoveryEmails'];\n  readonly phoneCode?: TuserProps['phoneCode'];\n  readonly twoFaConfig?: TuserProps['twoFaConfig'];\n  readonly preferredLoginMethod?: TuserProps['preferredLoginMethod'];\n\n  /**\n   * Constructs a {@link User} instance from provided data after basic validation.\n   *\n   * Ensures at least one contact method exists and validates common fields.\n   *\n   * @param data - The user data to initialize the model with.\n   * @throws {@link BizNestClientValidationError} If required fields are invalid.\n   */\n  constructor(data: TuserProps) {\n    validateData(data, {\n      urId: {\n        validate: (v) =>\n          typeof v === 'string' &&\n          v.trim().length > 0,\n        message: 'User ID must be a non-empty string'\n      },\n      email: {\n        required: false,\n        validate: (v) =>\n          v === undefined ||\n          (typeof v === 'string' &&\n          /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(v)),\n        message: 'Invalid email format'\n      },\n      phone: {\n        required: false,\n        validate: (v) =>\n          typeof v === 'string' &&\n          v.trim().length > 0,\n        message: 'Phone must be a non-empty string'\n      },\n      verified: {\n        required: false,\n        validate: (v) => typeof v === 'boolean',\n        message: 'Verified must be a boolean'\n      }\n    });\n\n    super(data);\n\n    this.urId = data.urId;\n\n    this.firstName = data.firstName;\n    this.lastName = data.lastName;\n    this.email = data.email;\n    this.profilePicture = data.profilePicture;\n    this.profileCoverPicture = data.profileCoverPicture;\n    this.phone = data.phone;\n    this.verified = data.verified || false;\n    this.socialAuthFrameworks = data.socialAuthFrameworks;\n    this.phoneVerificationMeta = data.phoneVerificationMeta;\n    this.emailVerificationMeta = data.emailVerificationMeta;\n    this.recoveryPhoneNumbers = data.recoveryPhoneNumbers;\n    this.recoveryEmails = data.recoveryEmails;\n    this.phoneCode = data.phoneCode;\n    this.twoFaConfig = data.twoFaConfig;\n    this.preferredLoginMethod = data.preferredLoginMethod;\n  }\n\n  /**\n   * The user's displayable name (first and last concatenated).\n   */\n  get names() {\n    return `${this.firstName} ${this.lastName}`.trim();\n  }\n\n  /**\n   * The user's full display name (alias of {@link User.names}).\n   */\n  get fullNames() {\n    return `${this.firstName} ${this.lastName}`.trim();\n  }\n\n  /**\n   * Retrieves all users with pagination.\n   *\n   * @param offset - The starting point for the list of users. Defaults to `0`.\n   * @param limit - The maximum number of users to retrieve. Defaults to `20`.\n   * @returns A promise that resolves to an object containing the count and an\n   * array of {@link User} instances.\n   */\n  static async getAll(offset = 0, limit = 20) {\n    const query = new URLSearchParams({\n      offset: offset.toString(),\n      limit: limit.toString()\n    }).toString();\n    const observer$ = AuthClient.ehttp\n      .makeGet<IdataArrayResponse<TuserProps>>(`${User.baseUrl}?${query}`);\n    const users = await lastValueFrom(observer$);\n\n    return {\n      count: users.count,\n      dataArr: users.data.map(val => new User(val))\n    };\n  }\n\n  /**\n   * Filters users based on provided criteria.\n   *\n   * @param filter - The filter criteria for retrieving users.\n   * @returns A promise that resolves to an object containing the count and an\n   * array of {@link User} instances.\n   */\n  static async filterAll(filter: IfilterProps) {\n    const observer$ = AuthClient.ehttp.makePost<IdataArrayResponse<TuserProps>>(`${User.baseUrl}/filter`, filter);\n    const users = await lastValueFrom(observer$);\n\n    return {\n      count: users.count,\n      dataArr: users.data.map(val => new User(val))\n    };\n  }\n\n  /**\n   * Retrieves a single user by ID.\n   *\n   * @param resourceId - The unique identifier of the user.\n   * @returns A promise that resolves to the {@link User} instance.\n   */\n  static async getOne(resourceId: string) {\n    const observer$ = AuthClient.ehttp.makeGet<TuserProps>(`${User.baseUrl}/${resourceId}`);\n\n    return new User(await lastValueFrom(observer$));\n  }\n\n  /**\n   * Updates a user by identifier with the provided payload.\n   *\n   * @param _id - The user identifier to update.\n   * @param payload - The update request body.\n   * @returns A promise that resolves to the updated {@link User} instance.\n   */\n  static async updateOne(_id: string, payload: TuserRequest) {\n    const observer$ = AuthClient.ehttp\n      .makePut<TuserProps>(`${User.baseUrl}/${_id}`, payload);\n\n    return new User(await lastValueFrom(observer$));\n  }\n\n  /**\n   * Updates the current user's profile with the provided payload.\n   *\n   * @param payload - The update request body.\n   * @returns A promise that resolves to the updated {@link User} instance.\n   */\n  async updateProfile(payload: TuserRequest) {\n    const observer$ = AuthClient.ehttp\n      .makePut<TuserProps>(`${User.baseUrl}/${this._id}`, payload);\n\n    return new User(await lastValueFrom(observer$));\n  }\n\n\n  /**\n   * Uploads a new profile picture for the current user instance.\n   *\n   * @param file - The image file to upload.\n   * @returns An observable that emits the updated user DTO.\n   */\n  uploadProfilePicture(file: Ifile) {\n    return AuthClient.ehttp\n      .uploadFiles<TuserProps>([file], `${User.baseUrl}/upload-profile-picture`, { _id: this._id });\n  }\n\n  /**\n   * Uploads a new profile cover picture for the current user instance.\n   *\n   * @param file - The image file to upload.\n   * @returns An observable that emits the updated user DTO.\n   */\n  uploadProfileCoverPicture(file: Ifile) {\n    return AuthClient.ehttp\n      .uploadFiles<TuserProps>([file], `${User.baseUrl}/upload-profile-cover-picture`, { _id: this._id });\n  }\n\n  /**\n   * Removes images associated with the current user instance.\n   *\n   * @param fileIds - The image identifiers to remove.\n   * @returns A promise that resolves to the updated {@link User} instance.\n   */\n  async deleteImages(fileIds: string[]) {\n    const observer$ = AuthClient.ehttp\n      .makePost<TuserProps>(`${User.baseUrl}/delete-images`, { fileIds, _id: this._id });\n\n\n    return new User(await lastValueFrom(observer$));\n  }\n}\n", "/* eslint-disable max-lines */\nimport {\n  BizNestClientError, FrontendLogger, Iauthresponse,\n  IauthTokenResponse,\n  IchangeEmailRes, IchangePhoneRes,\n  IpermProp,\n  IrecoveryTokenRes, IresetPasswordRes, IsignupRes, Iuser,\n  IuserPermission,\n  IwsAuthTokenResponse\n} from '@biz-nest/core-client';\nimport { lastValueFrom } from 'rxjs';\nimport { AuthClient } from '../auth-client';\nimport { User } from '../defines/user.define';\n\n/**\n * Login payload for username/password authentication.\n *\n * @public\n */\nexport interface IidentityInfo {\n\n  /** Optional number of days to remember the session. */\n  rememberMeDays?: number;\n\n  /** Login email, if using email credential flow. */\n  email?: string;\n\n  /** Login phone, if using phone credential flow. */\n  phone?: string;\n}\n\nexport interface IidentityRes {\n  method: Iuser['preferredLoginMethod'];\n  identifier: string;\n}\n\n/**\n * Login payload for username/password authentication.\n *\n * @public\n */\nexport interface IloginInfo {\n\n  /** Optional number of days to remember the session. */\n  rememberMeDays?: number;\n\n  /** Login email, if using email credential flow. */\n  email?: string;\n\n  /** Login phone, if using phone credential flow. */\n  phone?: string;\n\n  /** Plain-text password to authenticate. */\n  password?: string;\n\n  /** Login method, if using passwordless flow. */\n  loginMethod: Iuser['preferredLoginMethod'];\n}\n\n/**\n * Signup payload for new account creation.\n *\n * @public\n */\nexport interface IsignupInfo {\n\n  /** Email to register (optional if using phone). */\n  email?: string;\n\n  /** Phone to register (optional if using email). */\n  phone?: string;\n\n  /** Account password. */\n  password: string;\n\n  /** First name of the user. */\n  firstName?: string;\n\n  /** Last name of the user. */\n  lastName?: string;\n}\n\n/**\n * Signup payload for new account creation.\n *\n * @public\n */\nexport interface IpasswordlessSignupInfo {\n\n  /** Email to register (optional if using phone). */\n  email?: string;\n\n  /** Phone to register (optional if using email). */\n  phone?: string;\n\n  /** First name of the user. */\n  firstName?: string;\n\n  /** Last name of the user. */\n  lastName?: string;\n}\n\n\n/**\n * Recovery payload for initiating account recovery.\n *\n * @public\n */\nexport interface IsendRecoveryTokenInfo {\n\n  /** Email to recover (optional if using phone). */\n  email?: string;\n\n  /** Phone to recover (optional if using email). */\n  phone?: string;\n\n  /** Alternate recovery phone, if used by the flow. */\n  recoveryPhone?: string;\n\n  /** Alternate recovery email, if used by the flow. */\n  recoveryEmail?: string;\n}\n\n/**\n * Payload for changing email address.\n *\n * @public\n */\nexport interface IchangeEmailInfo {\n  email: string;\n}\n\n/**\n * Recovery payload for initiating account recovery.\n *\n * @public\n */\nexport interface IchangePhoneInfo {\n  phone: string;\n}\n\n/**\n * Payload for initiating password reset.\n *\n * @public\n */\nexport interface IpasswordResetPayload {\n\n  /** Email to recover (optional if using phone). */\n  email?: string;\n\n  /** Phone to recover (optional if using email). */\n  phone?: string;\n\n  /** Alternate recovery phone, if used by the flow. */\n  recoveryPhone?: string;\n\n  /** Alternate recovery email, if used by the flow. */\n  recoveryEmail?: string;\n}\n\n/**\n * Payload for account verification.\n *\n * @public\n */\nexport interface IverificationInfo {\n\n  /** Verification code provided by email/SMS/link. */\n  verificationCode: string;\n}\n\n/**\n * Payload for resetting password.\n *\n * @public\n */\nexport interface IresetPasswordInfo {\n\n  /** Verification code provided by email/SMS/link. */\n  verificationCode: string;\n\n  /** New password to set. */\n  password: string;\n}\n\n/**\n * Payload for changing password.\n *\n * @public\n */\nexport interface IchangePasswordInfo {\n\n  /** Current password (required for password change), if social login or passwordless it might have not be set. */\n  oldPassword?: string;\n\n  /** New password to set. */\n  password: string;\n}\n\n/**\n * Payload for adding password to passwordless account.\n *\n * @public\n */\nexport interface IaddPasswordPayload {\n\n  /** Verification code provided by email/SMS/link. */\n  verificationCode: string;\n\n  /** Password to set for the account. */\n  password: string;\n}\n\n\n/**\n * Retrieves the currently authenticated user (JWT-based).\n *\n * @returns A promise that resolves to the authenticated {@link User}.\n */\nexport const me = async(): Promise<User> => {\n  FrontendLogger.debug('AuthService:me::');\n  const observer$ = AuthClient.ehttp\n    .makeGet<Iuser>('/auth/me');\n\n  const res = await lastValueFrom(observer$);\n\n  return new User(res);\n};\n\n/**\n * Retrieves the currently authenticated admin metadata.\n *\n * @returns A promise resolving to the auth response plus default currency.\n */\nexport const meAdmin = (): Promise<Iauthresponse & { defaultCurrency: string }> => {\n  FrontendLogger.debug('AuthService:meAdmin::');\n  const observer$ = AuthClient.ehttp\n    .makeGet<Iauthresponse & { defaultCurrency: string }>('/admin/me');\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Initiates an admin login (OTP or token-based depending on backend).\n *\n * @param params - Optional email or phone to identify the admin.\n * @returns A promise resolving to an auth token response.\n */\nexport const adminLogin = ({\n  email,\n  phone\n}: {\n  email?: string;\n  phone?: string;\n}): Promise<IauthTokenResponse> => {\n  FrontendLogger.debug('AuthService:adminLogin');\n  const observer$ = AuthClient.ehttp\n    .makePost<IauthTokenResponse>('/admin/login', { email, phone });\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Verifies an admin login challenge (e.g., OTP), finalizing authentication.\n *\n * @param params - Contains the verification token and optional rememberMeDays.\n * @returns A promise resolving to the auth response.\n */\nexport const adminVerify = ({\n  verificationToken,\n  rememberMeDays\n}: {\n  verificationToken: string;\n  rememberMeDays?: number;\n}): Promise<Iauthresponse> => {\n  FrontendLogger.debug('AuthService:adminVerify');\n  const observer$ = AuthClient.ehttp\n    .makePost<Iauthresponse>('/admin/verify', { verificationToken, rememberMeDays });\n\n  return lastValueFrom(observer$);\n};\n\n\n/**\n * Begins a Google OAuth login by navigating to the backend-provided URL.\n *\n * @param queryParams - Optional parameters to pass to the login URL.\n * @returns The opened window handle (if available).\n * @throws {@link BizNestClientError} If the Google login URL is not configured.\n */\nexport const googleLogin = (queryParams?: Record<string, string>): Window | null => {\n  FrontendLogger.debug('AuthService:googleLogin');\n\n  if (!AuthClient.socialCallUrls?.google) {\n    throw new BizNestClientError('Google login URL not found');\n  }\n\n  let targetUrl = AuthClient.socialCallUrls.google;\n\n  // Append query parameters if provided\n  if (queryParams) {\n    const url = new URL(targetUrl, window.location.origin);\n\n    Object.keys(queryParams).forEach(key => {\n      if (queryParams[key]) {\n        url.searchParams.set(key, queryParams[key]);\n      }\n    });\n\n    targetUrl = url.toString();\n  }\n\n\n  return window?.open(targetUrl, '_self');\n};\n\n\n/**\n * Begins a Facebook OAuth login by navigating to the backend-provided URL.\n *\n * @param queryParams - Optional parameters to pass to the login URL.\n * @returns The opened window handle (if available).\n * @throws {@link BizNestClientError} If the Facebook login URL is not configured.\n */\nexport const facebookLogin = (queryParams?: Record<string, string>): Window | null => {\n  FrontendLogger.debug('AuthService:facebookLogin');\n\n  if (!AuthClient.socialCallUrls?.facebook) {\n    throw new BizNestClientError('Facebook login URL not found');\n  }\n\n  let targetUrl = AuthClient.socialCallUrls.facebook;\n\n  // Append query parameters if provided\n  if (queryParams) {\n    const url = new URL(targetUrl, window.location.origin);\n\n    Object.keys(queryParams).forEach(key => {\n      if (queryParams[key]) {\n        url.searchParams.set(key, queryParams[key]);\n      }\n    });\n\n    targetUrl = url.toString();\n  }\n\n  return window?.open(targetUrl, '_self');\n};\n\n/**\n * Authenticates a user with email/phone and password.\n *\n * @param payload - The login payload; must include either email or phone.\n * @returns A promise resolving to an auth token response.\n * @throws {@link BizNestClientError} If neither email nor phone is provided.\n */\nexport const identity = (payload: IidentityInfo): Promise<IidentityRes> => {\n  if (!payload.email && !payload.phone) {\n    throw new BizNestClientError('Either email or phone number must be provided');\n  }\n  FrontendLogger.debug('AuthService:identity');\n  const observer$ = AuthClient.ehttp.makePost<IidentityRes>(\n    '/auth/identity',\n    { email: payload.email, phone: payload.phone }\n  );\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Authenticates a user with email/phone and password.\n *\n * @param payload - The login payload; must include either email or phone.\n * @returns A promise resolving to an auth token response.\n * @throws {@link BizNestClientError} If neither email nor phone is provided.\n */\nexport const login = (payload: IloginInfo): Promise<IauthTokenResponse & {\n  identifier: string; twoFaMethodEnabled: boolean; twoFaMethod: string; }> => {\n  if (!payload.email && !payload.phone) {\n    throw new BizNestClientError('Either email or phone number must be provided');\n  }\n  FrontendLogger.debug('AuthService:login');\n  const observer$ = AuthClient.ehttp.makePost<IauthTokenResponse & {\n    identifier: string; twoFaMethodEnabled: boolean; twoFaMethod: string; }>(\n      '/auth/login',\n      { email: payload.email,\n        phone: payload.phone,\n        password: payload.password,\n        rememberMeDays: payload.rememberMeDays,\n        loginMethod: payload.loginMethod\n      }\n    );\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Verifies a user's 2FA code.\n *\n * @param payload - The 2FA verification payload; must include the verification code.\n * @returns A promise resolving to an auth token response.\n * @throws {@link BizNestClientError} If the verification code is missing.\n */\nexport const login2fa = (payload: { verificationCode: string }): Promise<IauthTokenResponse> => {\n  FrontendLogger.debug('AuthService:login2fa');\n  const observer$ = AuthClient.ehttp.makePost<IauthTokenResponse>(\n    '/auth/2fa/login',\n    payload\n  );\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Registers a new user.\n *\n * @param payload - The signup payload; must include either email or phone.\n * @returns A promise resolving to an auth response.\n * @throws {@link BizNestClientError} If neither email nor phone is provided.\n */\nexport const signup = (payload: IsignupInfo): Promise<IsignupRes> => {\n  if (!payload.email && !payload.phone) {\n    throw new BizNestClientError('Either email or phone number must be provided');\n  }\n  const details = {\n    email: payload.email,\n    phone: payload.phone,\n    password: payload.password,\n    firstName: payload.firstName,\n    lastName: payload.lastName\n  };\n\n  const observer$ = AuthClient.ehttp\n    .makePost<IsignupRes>('/auth/signup', details);\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Initiates password reset.\n *\n * @param payload - The recovery payload; must include either email or phone.\n * @returns A promise resolving to a recovery token response.\n * @throws {@link BizNestClientError} If neither email nor phone is provided.\n */\nexport const initiatePasswordReset = (payload: IpasswordResetPayload): Promise<IresetPasswordRes> => {\n  if (!payload.email && !payload.phone) {\n    throw new BizNestClientError('Either email or phone number must be provided');\n  }\n  FrontendLogger.debug('AuthService:sendRecoveryToken');\n  const observer$ = AuthClient.ehttp\n    .makePost<IrecoveryTokenRes>('/auth/password-resets/initiate', payload);\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Resets user password using a code or link.\n *\n * @param payload - The reset password payload.\n * @returns A promise resolving to an auth token response.\n */\nexport const finalizePasswordReset = (payload: IresetPasswordInfo): Promise<IauthTokenResponse> => {\n  FrontendLogger.debug('AuthService:finalizePasswordReset');\n  const observer$ = AuthClient.ehttp\n    .makePost<IauthTokenResponse>('/auth/password-resets/finalize', payload);\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Finalizes password reset.\n *\n * @param payload - The reset password payload.\n * @returns A promise resolving to an auth token response.\n */\nexport const changePassword = async(payload: IchangePasswordInfo): Promise<User> => {\n  FrontendLogger.debug('AuthService:finalizePasswordReset');\n  const observer$ = AuthClient.ehttp\n    .makePost<Iuser>('/auth/change-password', payload);\n\n  return new User(await lastValueFrom(observer$));\n};\n\n/**\n * Changes user login method.\n *\n * @param payload - The change login method payload.\n * @returns A promise resolving to a user object.\n */\nexport const changeLoginMethod = async(payload: { method: 'password' | 'passwordless' }): Promise<User> => {\n  FrontendLogger.debug('AuthService:changeLoginMethod');\n  const observer$ = AuthClient.ehttp\n    .makePost<Iuser>('/auth/change-login-method', payload);\n\n  return new User(await lastValueFrom(observer$));\n};\n\n/**\n * Initiates change email.\n *\n * @param payload - The change email payload.\n * @returns A promise resolving to a recovery token response.\n */\nexport const initiateChangeEmail = (payload: IchangeEmailInfo): Promise<IchangeEmailRes> => {\n  FrontendLogger.debug('AuthService:sendRecoveryToken');\n  const observer$ = AuthClient.ehttp\n    .makePost<IchangeEmailRes>('/auth/change-email/initiate', payload);\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Finalizes change email.\n *\n * @param payload - The change email payload.\n * @returns A promise resolving to a change email response.\n */\nexport const finalizeChangeEmail = async(payload: { verificationCode: string }): Promise<User> => {\n  FrontendLogger.debug('AuthService:finalizePasswordReset');\n  const observer$ = AuthClient.ehttp\n    .makePost<Iuser>('/auth/change-email/finalize', payload);\n\n  return new User(await lastValueFrom(observer$));\n};\n\n/**\n * Initiates change phone.\n *\n * @param payload - The change phone payload.\n * @returns A promise resolving to a recovery token response.\n */\nexport const initiateChangePhone = (payload: IchangePhoneInfo): Promise<IchangePhoneRes> => {\n  FrontendLogger.debug('AuthService:sendRecoveryToken');\n  const observer$ = AuthClient.ehttp\n    .makePost<IchangePhoneRes>('/auth/change-phone/initiate', payload);\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Finalizes change phone.\n *\n * @param payload - The change phone payload.\n * @returns A promise resolving to a change phone response.\n */\nexport const finalizeChangePhone = async(payload: { verificationCode: string }): Promise<User> => {\n  FrontendLogger.debug('AuthService:finalizePasswordReset');\n  const observer$ = AuthClient.ehttp\n    .makePost<Iuser>('/auth/change-phone/finalize', payload);\n\n  return new User(await lastValueFrom(observer$));\n};\n\n/**\n * Initiates 2FA enrollment.\n *\n * @param payload - The verification payload.\n * @returns A promise resolving to a recovery token response.\n */\nexport const initiate2faEnrollment = (payload: {\n  method: 'email' | 'phone';\n  email?: string;\n  phone?: string;\n}): Promise<{ message: string }> => {\n  FrontendLogger.debug('AuthService:sendRecoveryToken');\n  const observer$ = AuthClient.ehttp\n    .makePost<{ message: string }>('/auth/2fa/enroll/initiate', payload);\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Finalizes 2FA enrollment.\n *\n * @param payload - The verification payload.\n * @returns A promise resolving to a change phone response.\n */\nexport const finalize2faEnrollment = async(payload: {\n  verificationCode: string;\n}): Promise<User> => {\n  FrontendLogger.debug('AuthService:finalizePasswordReset');\n  const observer$ = AuthClient.ehttp\n    .makePost<Iuser>('/auth/2fa/enroll/finalize', payload);\n\n  return new User(await lastValueFrom(observer$));\n};\n\n/**\n * Initiates 2FA change.\n *\n * @param payload - The verification payload.\n * @returns A promise resolving to a recovery token response.\n */\nexport const initiate2faChange = (payload: {\n  method: 'email' | 'phone';\n  email?: string;\n  phone?: string;\n}): Promise<{ message: string }> => {\n  FrontendLogger.debug('AuthService:sendRecoveryToken');\n  const observer$ = AuthClient.ehttp\n    .makePost<{ message: string }>('/auth/2fa/change/initiate', payload);\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Finalizes 2FA change.\n *\n * @param payload - The verification payload.\n * @returns A promise resolving to a change phone response.\n */\nexport const finalize2faChange = async(payload: {\n  verificationCode: string;\n}): Promise<User> => {\n  FrontendLogger.debug('AuthService:finalizePasswordReset');\n  const observer$ = AuthClient.ehttp\n    .makePost<Iuser>('/auth/2fa/change/finalize', payload);\n\n  return new User(await lastValueFrom(observer$));\n};\n\n/**\n * Initiates 2FA disable.\n *\n * @returns A promise resolving to a recovery token response.\n */\nexport const initiate2faDisable = (): Promise<{ message: string }> => {\n  FrontendLogger.debug('AuthService:initiate2faDisable');\n  const observer$ = AuthClient.ehttp\n    .makePost<{ message: string }>('/auth/2fa/disable/initiate', {});\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Finalizes 2FA disable.\n *\n * @param payload - The verification payload.\n * @returns A promise resolving to a change phone response.\n */\nexport const finalize2faDisable = async(payload: {\n  verificationCode: string;\n}): Promise<User> => {\n  FrontendLogger.debug('AuthService:finalize2faDisable');\n  const observer$ = AuthClient.ehttp\n    .makePost<Iuser>('/auth/2fa/disable/finalize', payload);\n\n  return new User(await lastValueFrom(observer$));\n};\n\n\n/**\n * Verifies user account using a code or link.\n *\n * @param payload - The verification payload.\n * @returns A promise resolving to an auth token response.\n */\nexport const verifyAccount = (payload: IverificationInfo): Promise<IauthTokenResponse> => {\n  FrontendLogger.debug('AuthService:verify');\n  const observer$ = AuthClient.ehttp\n    .makePost<IauthTokenResponse>('/auth/verify-account', payload);\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Resends verification code to user's email or phone.\n *\n * @param payload - The resend verification code payload.\n * @returns A promise resolving to a resend verification code response.\n */\nexport const resendVerificationCode = (payload: { email?: string; phone?: string }): Promise<{ message: string }> => {\n  FrontendLogger.debug('AuthService:resendVerificationCode');\n  const observer$ = AuthClient.ehttp\n    .makePost<{ message: string }>('/auth/resend-verification-code', payload);\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Resends verification code to user's email or phone.\n *\n * @param payload - The resend verification code payload.\n * @returns A promise resolving to a resend verification code response.\n */\nexport const resendVerificationCodePasswordless = (payload: { email?: string;\n  phone?: string; }): Promise<{ message: string }> => {\n  FrontendLogger.debug('AuthService:resendVerificationCodePasswordless');\n  const observer$ = AuthClient.ehttp\n    .makePost<{ message: string }>('/auth/resend-verification-code/passwordless', payload);\n\n  return lastValueFrom(observer$);\n};\n\n\n/**\n * Registers a new user passwordless (alternate signup flow).\n *\n * @param payload - The signup payload; must include either email or phone.\n * @returns A promise resolving to an auth response.\n * @throws {@link BizNestClientError} If neither email nor phone is provided.\n */\nexport const signupPasswordless = (payload: IpasswordlessSignupInfo): Promise<IsignupRes> => {\n  FrontendLogger.debug('AuthService:signupPasswordless');\n  if (!payload.email && !payload.phone) {\n    throw new BizNestClientError('Either email or phone number must be provided');\n  }\n\n  const observer$ = AuthClient.ehttp\n    .makePost<IsignupRes>('/auth/passwordless/signup', payload);\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Verifies passwordless verification using a code or link.\n *\n * @param payload - The verification payload.\n * @returns A promise resolving to an auth token response.\n */\nexport const verifyPasswordless = (payload: IverificationInfo): Promise<IauthTokenResponse> => {\n  FrontendLogger.debug('AuthService:verifyPasswordless');\n  const observer$ = AuthClient.ehttp\n    .makePost<IauthTokenResponse>('/auth/passwordless/verify', payload);\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Verifies passwordless verification using a code or link.\n *\n * @param payload - The verification payload.\n * @returns A promise resolving to an auth token response.\n */\nexport const loginPasswordless = (payload: IverificationInfo): Promise<IauthTokenResponse> => {\n  FrontendLogger.debug('AuthService:loginPasswordless');\n  const observer$ = AuthClient.ehttp\n    .makePost<IauthTokenResponse>('/auth/passwordless/login', payload);\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Retrieves available recovery methods (phones/emails) for a user.\n *\n * @param userId - The user identifier.\n * @returns A promise resolving to the recovery phone numbers and emails.\n */\nexport const recoveryMethod = (userId: string): Promise<{\n  recoveryPhoneNumbers: string[]; recoveryEmails: string[]; }> => {\n  const observer$ = AuthClient.ehttp\n    .makeGet<{recoveryPhoneNumbers: string[]; recoveryEmails: string[] }>(`/auth/recovery-methods-list/${userId}`);\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Fetches permissions assigned to a user.\n *\n * @param userId - The user identifier.\n * @returns A promise resolving to the user's permissions.\n */\nexport const getUserPermissions = (userId: string): Promise<IuserPermission> => {\n  const observer$ = AuthClient.ehttp\n    .makeGet<IuserPermission>(`/auth/get-user-permissions/${userId}`);\n\n  return lastValueFrom(observer$);\n};\n\n\n/**\n * Fetches permissions assigned to the current user.\n *\n * @returns A promise resolving to the user's permissions.\n */\nexport const getMyPermissions = (): Promise<IuserPermission> => {\n  const observer$ = AuthClient.ehttp\n    .makeGet<IuserPermission>('/auth/get-my-permissions');\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Updates a user's permissions.\n *\n * @param userId - The user identifier.\n * @param payload - Permission map; values may be boolean or permission prop.\n * @returns A promise resolving to the updated user permissions.\n */\nexport const updateUserPermissions = (\n  userId: string,\n  payload: { [x: string]: boolean | IpermProp }\n): Promise<IuserPermission> => {\n  const observer$ = AuthClient.ehttp\n    .makePut<IuserPermission>(`/auth/update-user-permissions/${userId}`, payload);\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Adds a recovery phone for the current user.\n *\n * @param phone - The phone number to add.\n * @param phoneCode - Country code for the phone number (e.g., +256).\n * @returns A promise resolving to a success and message object.\n */\nexport const addRecoveryPhone = (phone: string, phoneCode: string): Promise< {\n  success: boolean;\n  message: string;\n}> => {\n  const observer$ = AuthClient.ehttp\n    .makePost<{ success: boolean; message: string }>('/auth/add-recovery-phone', { phone, phoneCode });\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Verifies a recovery phone using a verification code.\n *\n * @param phone - The recovery phone to verify.\n * @param verificationCode - The received verification code.\n * @returns A promise resolving to a user object.\n */\nexport const verifyRecoveryPhone = async(phone: string, verificationCode: string): Promise<User> => {\n  const observer$ = AuthClient.ehttp\n    .makePost<Iuser>('/auth/verify-recovery-phone', { phone, verificationCode });\n\n  return new User(await lastValueFrom(observer$));\n};\n\n/**\n * Removes a recovery phone.\n *\n * @param phone - The phone number to remove.\n * @returns A promise resolving to a user object.\n */\nexport const removeRecoveryPhone = async(phone: string): Promise<User> => {\n  const observer$ = AuthClient.ehttp\n    .makePost<Iuser>('/auth/remove-recovery-phone', { phone });\n\n  return new User(await lastValueFrom(observer$));\n};\n\n/**\n * Retrieves the recovery phone numbers for the current user.\n *\n * @returns A promise resolving to an array of recovery phone numbers.\n */\nexport const getRecoveryPhoneNumbers = (): Promise<string[]> => {\n  const observer$ = AuthClient.ehttp\n    .makeGet<string[]>('/auth/get-recovery-phone-numbers');\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Retrieves the recovery email addresses for the current user.\n *\n * @returns A promise resolving to an array of recovery email addresses.\n */\nexport const getRecoveryEmails = (): Promise<string[]> => {\n  const observer$ = AuthClient.ehttp\n    .makeGet<string[]>('/auth/get-recovery-emails');\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Adds a recovery email for the current user.\n *\n * @param email - The email address to add.\n * @returns A promise resolving to a success and message object.\n */\nexport const addRecoveryEmail = (email: string): Promise<{success: boolean; message: string}> => {\n  const observer$ = AuthClient.ehttp\n    .makePost<{success: boolean; message: string}>('/auth/add-recovery-email', { email });\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Verifies a recovery email using a verification code.\n *\n * @param email - The recovery email to verify.\n * @param verificationCode - The received verification code.\n * @returns A promise resolving to a user object.\n */\nexport const verifyRecoveryEmail = async(email: string, verificationCode: string): Promise<User> => {\n  const observer$ = AuthClient.ehttp.makePost<Iuser>('/auth/verify-recovery-email', { email, verificationCode });\n\n  return new User(await lastValueFrom(observer$));\n};\n\n/**\n * Removes a recovery email.\n *\n * @param email - The email address to remove.\n * @returns A promise resolving to a user object.\n */\nexport const removeRecoveryEmail = async(email: string): Promise<User> => {\n  const observer$ = AuthClient.ehttp\n    .makePost<Iuser>('/auth/remove-recovery-email', { email });\n\n  return new User(await lastValueFrom(observer$));\n};\n\n/**\n * Checks if a user exists by email or phone.\n *\n * @param params - Contains optional `email` and `phone` to check.\n * @returns A promise resolving to true if a user exists for either field.\n */\nexport const existsEmailOrPhone = async({ email, phone }: {email: string; phone: string}): Promise<boolean> => {\n  const observer$ = AuthClient.ehttp\n    .makePost<{ exists: boolean }>('/auth/exists-email-phone', { email, phone });\n  const response = await lastValueFrom(observer$);\n\n  return response.exists;\n};\n\n\n/**\n * Logs the current user out of the application.\n *\n * @returns A promise that resolves when the logout is complete.\n */\nexport const logout = (): Promise<void> => {\n  const observer$ = AuthClient.ehttp\n    .makePost('/auth/logout', {});\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Logs the current user into the application using WebSockets.\n *\n * @returns A promise resolving to an auth token response.\n */\nexport const wsLogin = (): Promise<IwsAuthTokenResponse> => {\n  const observer$ = AuthClient.ehttp\n    .makePost<IwsAuthTokenResponse>('/auth/ws-login', {});\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Refreshes the current user's authentication token using WebSockets.\n *\n * @returns A promise resolving to a fresh auth token response.\n */\nexport const wsRefresh = (): Promise<IwsAuthTokenResponse> => {\n  const observer$ = AuthClient.ehttp\n    .makePost<IwsAuthTokenResponse>('/auth/ws-refresh', {});\n\n  return lastValueFrom(observer$);\n};\n\n/**\n * Logs the current user out of the application using WebSockets.\n *\n * @returns A promise that resolves when the logout is complete.\n */\nexport const wsLogout = (): Promise<void> => {\n  const observer$ = AuthClient.ehttp\n    .makePost('/auth/ws-logout', {});\n\n  return lastValueFrom(observer$);\n};\n"],
  "mappings": "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",
  "names": []
}
