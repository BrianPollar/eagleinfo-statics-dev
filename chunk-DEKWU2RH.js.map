{
  "version": 3,
  "sources": ["../../biz-nest/packages/notification/client/src/defines/notif-api-key.define.ts", "../../biz-nest/packages/notification/client/src/notif-client.ts", "../../biz-nest/packages/notification/client/src/defines/notif-stn-user.define.ts", "../../biz-nest/packages/notification/client/src/defines/notification.define.ts"],
  "sourcesContent": ["import {\n  DatabaseAuto,\n  IdataArrayResponse,\n  IdeleteOneResponse,\n  IfilterProps,\n  InotifApiKey\n} from '@biz-nest/core-client';\nimport { lastValueFrom } from 'rxjs';\nimport { NotificationClient } from '../notif-client';\n\n/**\n * Represents a notification API key with its associated configuration and usage limits.\n * This class provides methods to manage notification API keys and their usage statistics.\n *\n * @class NotificationApiKey\n * @extends DatabaseAuto\n * @example\n * // Get all API keys with pagination\n * const { count, dataArr } = await NotificationApiKey.getAll(0, 10);\n *\n * // Create a new API key\n * const newKey = await NotificationApiKey.add({\n *   enabled: true,\n *   owner: 'user123',\n *   maxEmails: 1000,\n *   maxSms: 500\n * });\n */\nexport class NotificationApiKey extends DatabaseAuto {\n  /** Base URL for notification API key endpoints */\n  private static readonly baseUrl = '/notification-api-key';\n\n  /** The API key string used for authentication */\n  apiKey: InotifApiKey['apiKey'];\n\n  /** Whether the API key is currently enabled */\n  enabled: InotifApiKey['enabled'];\n\n  /** Optional expiration date for the API key */\n  expiresAt?: InotifApiKey['expiresAt'];\n\n  /** The owner/creator of the API key */\n  owner: InotifApiKey['owner'];\n\n  /** Maximum number of allowed emails (optional) */\n  maxEmails?: InotifApiKey['maxEmails'];\n\n  /** Maximum number of allowed SMS messages (optional) */\n  maxSms?: InotifApiKey['maxSms'];\n\n  /** Number of emails sent using this key (optional) */\n  usedEmails?: InotifApiKey['usedEmails'];\n\n  /** Number of SMS messages sent using this key (optional) */\n  usedSms?: InotifApiKey['usedSms'];\n\n  /** Last Used timestamp */\n  lastUsedAt?: InotifApiKey['lastUsedAt'];\n\n  /**\n   * Creates a new NotificationApiKey instance\n   * @param notifApiKey - The notification API key data\n   */\n  constructor(notifApiKey: InotifApiKey) {\n    super(notifApiKey);\n    this.apiKey = notifApiKey.apiKey;\n    this.enabled = notifApiKey.enabled;\n    this.expiresAt = notifApiKey.expiresAt;\n    this.owner = notifApiKey.owner;\n    this.maxEmails = notifApiKey.maxEmails;\n    this.maxSms = notifApiKey.maxSms;\n    this.usedEmails = notifApiKey.usedEmails;\n    this.usedSms = notifApiKey.usedSms;\n    this.lastUsedAt = notifApiKey.lastUsedAt;\n  }\n\n  /**\n   * Retrieves a paginated list of notification API keys\n   * @param {number} offset - The number of items to skip before starting to collect the result set\n   * @param {number} limit - The maximum number of items to return\n   * @returns {Promise<{count: number, dataArr: NotificationApiKey[]}>}\n   * An object containing the total count and array of API keys\n   * @throws {Error} If the API request fails\n   * @example\n   * // Get first 10 API keys\n   * const { count, dataArr } = await NotificationApiKey.getAll(0, 10);\n   */\n  static async getAll(offset: number, limit: number) {\n    const query = new URLSearchParams({\n      offset: offset.toString(),\n      limit: limit.toString()\n    }).toString();\n    const observer$ = NotificationClient.ehttp\n      .makeGet<IdataArrayResponse<InotifApiKey>>(`${NotificationApiKey.baseUrl}?${query}`);\n    const response = await lastValueFrom(observer$);\n\n    return {\n      count: response.count,\n      dataArr: response.data.map(val => new NotificationApiKey(val))\n    };\n  }\n\n  /**\n   * Retrieves notification API keys based on filter criteria\n   * @param {IfilterProps} filter - The filter criteria to apply\n   * @returns {Promise<{count: number, dataArr: NotificationApiKey[]}>} Filtered API keys with count\n   * @throws {Error} If the API request fails\n   * @example\n   * // Get all enabled API keys\n   * const { dataArr } = await NotificationApiKey.filterAll({\n   *   conditions: { enabled: true }\n   * });\n   */\n  static async filterAll(filter: IfilterProps) {\n    const observer$ = NotificationClient.ehttp\n      .makePost<IdataArrayResponse<InotifApiKey>>(\n        `${NotificationApiKey.baseUrl}/filter`,\n        { filter }\n      );\n    const response = await lastValueFrom(observer$);\n\n    return {\n      count: response.count,\n      dataArr: response.data.map(val => new NotificationApiKey(val))\n    };\n  }\n\n  /**\n   * Retrieves a single notification API key by ID\n   * @param {string} resourceId - The ID of the API key to retrieve\n   * @returns {Promise<NotificationApiKey>} The requested API key\n   * @throws {Error} If the API key is not found or request fails\n   * @example\n   * const apiKey = await NotificationApiKey.getOne('123abc');\n   */\n  static async getOne(resourceId: string) {\n    const observer$ = NotificationClient.ehttp\n      .makeGet<InotifApiKey>(`${NotificationApiKey.baseUrl}/${resourceId}`);\n    const response = await lastValueFrom(observer$);\n\n    return new NotificationApiKey(response);\n  }\n\n  /**\n   * Creates a new notification API key\n   * @param {Omit<InotifApiKey, '_id' | 'createdAt' | 'updatedAt'\n   * | 'apiKey' | 'usedEmails' | 'usedSms'>} payload - The API key configuration\n   * @returns {Promise<NotificationApiKey>} The newly created API key\n   * @throws {Error} If the API request fails or validation fails\n   * @example\n   * const newKey = await NotificationApiKey.add({\n   *   enabled: true,\n   *   owner: 'user123',\n   *   maxEmails: 1000,\n   *   maxSms: 500\n   * });\n   */\n  static async add(payload: Omit<\n    InotifApiKey, '_id' | 'createdAt' | 'updatedAt' | 'apiKey' | 'usedEmails' | 'usedSms'>) {\n    const observer$ = NotificationClient.ehttp\n      .makePost<InotifApiKey>(`${NotificationApiKey.baseUrl}`, payload);\n\n    return new NotificationApiKey(await lastValueFrom(observer$));\n  }\n\n  /**\n   * Updates the current API key's configuration\n   * @param {Omit<Partial<InotifApiKey>, '_id' | 'createdAt' |\n   * 'updatedAt' | 'apiKey' | 'usedEmails' | 'usedSms'>} payload - The fields to update\n   * @returns {Promise<NotificationApiKey>} The updated API key\n   * @throws {Error} If the update fails or API key doesn't exist\n   * @example\n   * // Disable an API key\n   * await apiKeyInstance.update({ enabled: false });\n   */\n  async update(payload: Omit<\n    Partial<InotifApiKey>, '_id' | 'createdAt' | 'updatedAt' | 'apiKey' | 'usedEmails' | 'usedSms'>) {\n    const observer$ = NotificationClient.ehttp\n      .makePut<InotifApiKey>(`${NotificationApiKey.baseUrl}/${this._id}`, payload);\n\n    return new NotificationApiKey(await lastValueFrom(observer$));\n  }\n\n  /**\n   * Deletes the current API key\n   * @returns {Promise<IdeleteOneResponse | null>} The result of the delete operation\n   * @throws {Error} If the deletion fails\n   * @example\n   * const result = await apiKeyInstance.remove();\n   * if (result?.success) {\n   *   console.log('API key deleted successfully');\n   * }\n   */\n  async remove(): Promise<IdeleteOneResponse | null> {\n    const observer$ = NotificationClient.ehttp\n      .makeDelete<IdeleteOneResponse | null>(`${NotificationApiKey.baseUrl}/${this._id}`);\n    const response = await lastValueFrom(observer$);\n\n    return response;\n  }\n\n  /**\n   * Checks if the API key has expired\n   * @returns {boolean} True if the API key has expired, false otherwise\n   */\n  isExpired() {\n    return this.expiresAt ? new Date(this.expiresAt) < new Date() : false;\n  }\n\n  /**\n   * Checks if the API key can send an email\n   * @returns {boolean} True if the API key can send an email, false otherwise\n   */\n  canSendEmail() {\n    if (!this.enabled || this.isExpired()) {\n      return false\n      ;}\n\n    return !this.maxEmails || (this.usedEmails || 0) < this.maxEmails;\n  }\n}\n", "import {\n  BizNestClientError,\n  EhttpController, FrontendLogger, IehttpControllerConfig\n} from '@biz-nest/core-client';\n\n/**\n * A client for interacting with the notification service.\n * This class provides HTTP client initialization and management for notification-related operations.\n *\n * @class NotificationClient\n * @example\n * // Initialize the notification client\n * const notificationClient = new NotificationClient({\n *   baseURL: 'https://api.example.com/notifications',\n *   timeout: 10000\n * });\n *\n * // Use the HTTP client\n * const response = await NotificationClient.ehttp.get('/some-endpoint');\n */\nexport class NotificationClient {\n  /** Singleton instance of the HTTP controller */\n  private static http: EhttpController;\n\n  /**\n   * Creates an instance of NotificationClient with comprehensive environment validation.\n   * @param {IehttpControllerConfig} config - Configuration object for the Axios HTTP client\n   * @throws {BizNestClientError} If the provided configuration is invalid\n   * @example\n   * const client = new NotificationClient({\n   *   baseURL: 'https://api.example.com',\n   *   timeout: 5000\n   * });\n   */\n  constructor(config: IehttpControllerConfig) {\n    if (!config || typeof config !== 'object') {\n      throw new BizNestClientError('config must be a valid object');\n    }\n\n    FrontendLogger.debug('NotificationClient initialized');\n    NotificationClient.http = new EhttpController(config);\n  }\n\n  /**\n   * Gets the singleton instance of the HTTP controller.\n   * @static\n   * @returns {EhttpController} The HTTP controller instance\n   * @throws {BizNestClientError} If the client has not been initialized\n   * @example\n   * // After initializing NotificationClient\n   * const httpClient = NotificationClient.ehttp;\n   * const response = await httpClient.get('/notifications');\n   */\n  static get ehttp(): EhttpController {\n    if (!NotificationClient.http) {\n      throw new BizNestClientError(`HTTP client not initialized. \n        Call new NotificationClient() with proper configuration first.`);\n    }\n\n    return NotificationClient.http;\n  }\n}\n", "import {\n  IfilterProps, InotifStnUser, TnotifStnUserRequest,\n  validateData\n} from '@biz-nest/core-client';\nimport { lastValueFrom } from 'rxjs';\nimport { NotificationClient } from '../notif-client';\n\n/**\n * Represents a user's notification settings in the system.\n * This class provides methods to manage notification preferences for users,\n * including email, SMS, push, and web notifications.\n *\n * @class NotifStnUser\n * @example\n * // Get notification settings for a user\n * const settings = await NotifStnUser.getOne('user123');\n *\n * // Update notification preferences\n * await settings.update({\n *   disableAll: false,\n *   channels: ['email', 'push'],\n *   allow: []\n * });\n */\nexport class NotifStnUser {\n  /** Base URL for notification settings endpoints */\n  static readonly baseUrl = '/notification-setting-user';\n\n  /** Unique identifier for the notification settings */\n  readonly _id: InotifStnUser['_id'];\n\n  /** ID of the user these settings belong to */\n  readonly authUser: InotifStnUser['authUser'];\n\n  /** Optional target IDs if these settings are target-specific */\n  readonly targetId?: InotifStnUser['targetId'];\n\n  /** Optional company ID if these settings are company-specific */\n  readonly company?: InotifStnUser['company'];\n\n  /** Whether all notifications are disabled */\n  readonly disableAll?: InotifStnUser['disableAll'];\n\n  /** Array of allowed notification settings */\n  readonly allow: InotifStnUser['allow'];\n\n  /** Notification frequency in minutes */\n  readonly frequency?: InotifStnUser['frequency'];\n\n  /** Array of enabled notification channels */\n  readonly channels?: InotifStnUser['channels'];\n\n  /** User's timezone for time-sensitive notifications */\n  readonly timezone?: InotifStnUser['timezone'];\n\n  /** User's preferred language for notifications */\n  readonly language?: InotifStnUser['language'];\n\n  /** Whether these notification settings are active */\n  readonly isActive?: InotifStnUser['isActive'];\n\n  /**\n   * Creates a new NotifStnUser instance with validated data\n   * @param {InotifStnUser} notifStnUser - The notification settings data\n   * @throws {Error} If the notification settings data is invalid\n   */\n  constructor(notifStnUser: InotifStnUser) {\n    const validChannels = ['email', 'sms', 'push', 'web'];\n\n    validateData(notifStnUser, {\n      _id: {\n        validate: (v) =>\n          typeof v === 'string' &&\n          v.trim().length > 0,\n        message: 'Unique identifier must be a non-empty string'\n      },\n      company: {\n        required: false,\n        validate: (v) =>\n          v === undefined ||\n          (typeof v === 'string' && v.trim().length > 0),\n        message: 'Company ID must be a non-empty string if provided'\n      },\n      disableAll: {\n        required: false,\n        validate: (v) =>\n          v === undefined ||\n          typeof v === 'boolean',\n        message: 'Disable all must be a boolean if provided'\n      },\n      allow: {\n        validate: (v) =>\n          Array.isArray(v) &&\n          v.every(setting =>\n            typeof setting === 'object' &&\n            setting !== null),\n        message: 'Allow must be an array of notification settings'\n      },\n      frequency: {\n        required: false,\n        validate: (v) =>\n          v === undefined ||\n          (typeof v === 'number' && v >= 0),\n        message: 'Frequency must be a non-negative number if provided'\n      },\n      channels: {\n        required: false,\n        validate: (v) =>\n          v === undefined ||\n          (Array.isArray(v) &&\n            v.every(channel =>\n              typeof channel === 'string' &&\n            validChannels.includes(channel))),\n        message: `Channels must be an array of valid notification channels: ${validChannels.join(', ')}`\n      },\n      timezone: {\n        required: false,\n        validate: (v) =>\n          v === undefined ||\n          typeof v === 'string',\n        message: 'Timezone must be a string if provided'\n      },\n      language: {\n        required: false,\n        validate: (v) =>\n          v === undefined ||\n          typeof v === 'string',\n        message: 'Language must be a string if provided'\n      },\n      isActive: {\n        required: false,\n        validate: (v) =>\n          v === undefined ||\n          typeof v === 'boolean',\n        message: 'Is active must be a boolean if provided'\n      }\n    });\n\n    this._id = notifStnUser._id;\n    this.authUser = notifStnUser.authUser;\n    this.company = notifStnUser.company;\n    this.disableAll = notifStnUser.disableAll;\n    this.allow = notifStnUser.allow;\n    this.frequency = notifStnUser.frequency;\n    this.channels = notifStnUser.channels;\n    this.timezone = notifStnUser.timezone;\n    this.language = notifStnUser.language;\n    this.isActive = notifStnUser.isActive;\n    this.targetId = notifStnUser.targetId;\n  }\n\n  /**\n   * Retrieves a paginated list of notification settings for users\n   * @param {number} offset - The number of items to skip before starting to collect the result set\n   * @param {number} limit - The maximum number of items to return\n   * @returns {Promise<NotifStnUser[]>} Array of notification settings\n   * @throws {Error} If the API request fails\n   * @example\n   * // Get first 10 notification settings\n   * const settings = await NotifStnUser.getAll(0, 10);\n   */\n  static async getAll(offset: number, limit: number): Promise<NotifStnUser[]> {\n    const query = new URLSearchParams({\n      offset: offset.toString(),\n      limit: limit.toString()\n    }).toString();\n    const observer$ = NotificationClient.ehttp\n      .makeGet<InotifStnUser[]>(`${NotifStnUser.baseUrl}?${query}`);\n    const response = await lastValueFrom(observer$);\n\n    return response.map(item => new NotifStnUser(item));\n  }\n\n  /**\n   * Retrieves notification settings based on filter criteria\n   * @param {IfilterProps} filter - The filter criteria to apply\n   * @returns {Promise<NotifStnUser[]>} Filtered notification settings\n   * @throws {Error} If the API request fails\n   * @example\n   * // Get notification settings for active users\n   * const activeSettings = await NotifStnUser.filterAll({\n   *   conditions: { isActive: true }\n   * });\n   */\n  static async filterAll(filter: IfilterProps): Promise<NotifStnUser[]> {\n    const observer$ = NotificationClient.ehttp\n      .makePost<InotifStnUser[]>(`${NotifStnUser.baseUrl}/filter`, { filter });\n    const response = await lastValueFrom(observer$);\n\n    return response.map(item => new NotifStnUser(item));\n  }\n\n  /**\n   * Retrieves notification settings for a specific user\n   * @param {string} resourceId - The ID of the notification settings to retrieve\n   * @returns {Promise<NotifStnUser>} The requested notification settings\n   * @throws {Error} If the settings are not found or request fails\n   * @example\n   * const userSettings = await NotifStnUser.getOne('user123');\n   */\n  static async getOne(resourceId: string): Promise<NotifStnUser> {\n    const observer$ = NotificationClient.ehttp\n      .makeGet<InotifStnUser>(`${NotifStnUser.baseUrl}/${resourceId}`);\n    const response = await lastValueFrom(observer$);\n\n    return new NotifStnUser(response);\n  }\n\n  /**\n   * Creates new notification settings for a user\n   * @param {TnotifStnUserRequest<true>} payload - The notification settings to create\n   * @returns {Promise<NotifStnUser>} The created notification settings\n   * @throws {Error} If creation fails or validation fails\n   * @example\n   * const newSettings = await NotifStnUser.add({\n   *   user: 'user123',\n   *   allow: [],\n   *   channels: ['email', 'push'],\n   *   isActive: true\n   * });\n   */\n  static async add(payload: TnotifStnUserRequest<true>): Promise<NotifStnUser> {\n    const observer$ = NotificationClient.ehttp\n      .makePost<InotifStnUser>(`${NotifStnUser.baseUrl}`, payload);\n\n    return new NotifStnUser(await lastValueFrom(observer$));\n  }\n\n  /**\n   * Updates the current notification settings\n   * @param {TnotifStnUserRequest} payload - The fields to update\n   * @returns {Promise<NotifStnUser>} The updated notification settings\n   * @throws {Error} If the update fails or settings don't exist\n   * @example\n   * // Disable email notifications\n   * await userSettings.update({\n   *   channels: ['push', 'sms']\n   * });\n   */\n  async update(payload: TnotifStnUserRequest): Promise<NotifStnUser> {\n    const observer$ = NotificationClient.ehttp\n      .makePut<InotifStnUser>(`${NotifStnUser.baseUrl}/${this._id}`, payload);\n\n    return new NotifStnUser(await lastValueFrom(observer$));\n  }\n}\n", "import {\n  DatabaseAuto, IdataArrayResponse,\n  IfilterProps, Imainnotification,\n  Isuccess, validateData\n} from '@biz-nest/core-client';\nimport { lastValueFrom } from 'rxjs';\nimport { NotificationClient } from '../notif-client';\n\n/**\n * Represents a main notification in the system.\n * This class provides methods to manage notifications including retrieving,\n * filtering, and marking them as read.\n *\n * @class NotificationMain\n * @extends DatabaseAuto\n * @example\n * // Get user notifications\n * const { count, dataArr } = await NotificationMain.getAll(0, 10);\n *\n * // Mark a notification as viewed\n * await notificationInstance.updateViewed();\n */\nexport class NotificationMain extends DatabaseAuto {\n  /** Base URL for notification endpoints */\n  static readonly baseUrl = '/notification';\n\n  /** ID of the user who can access this notification */\n  readonly authUser: Imainnotification['authUser'];\n\n  /** ID of the user who will receive this notification */\n  readonly targetId: Imainnotification['targetId'];\n\n  /** Type of the target ID (e.g., 'user', 'company') */\n  readonly targetType: Imainnotification['targetType'];\n\n  /** Title of the notification */\n  readonly title: Imainnotification['title'];\n\n  /** Main content/body of the notification */\n  readonly body: Imainnotification['body'];\n\n  /** Optional icon URL or identifier for the notification */\n  readonly icon?: Imainnotification['icon'];\n\n  /** Type/category of the notification */\n  readonly notifType?: Imainnotification['notifType'];\n\n  /** ID of the entity that triggered this notification */\n  readonly notifInvokerId?: Imainnotification['notifInvokerId'];\n\n  /** Expiration date for the notification */\n  readonly expireOn?: Imainnotification['expireOn'];\n\n  /** Whether the notification has been viewed */\n  readonly viewed: Imainnotification['viewed'];\n\n  /** Username of the notification recipient */\n  readonly username: Imainnotification['username'];\n\n  /** Email of the notification recipient */\n  readonly email?: Imainnotification['email'];\n\n  /** Phone number of the notification recipient */\n  readonly phone?: Imainnotification['phone'];\n\n  /** Country code for the phone number */\n  readonly phoneCode?: Imainnotification['phoneCode'];\n\n  /** Additional metadata for the notification */\n  readonly extraDetails?: Imainnotification['extraDetails'];\n\n  /**\n   * Creates a new NotificationMain instance with validated data\n   * @param {Imainnotification} data - The notification data\n   * @throws {Error} If the notification data is invalid\n   */\n  constructor(data: Imainnotification) {\n    validateData(data, {\n      title: {\n        validate: (v) =>\n          typeof v === 'string' &&\n          v.trim().length > 0,\n        message: 'Title must be a non-empty string'\n      },\n      body: {\n        validate: (v) =>\n          typeof v === 'string' &&\n          v.trim().length > 0,\n        message: 'Body must be a non-empty string'\n      },\n      icon: {\n        required: false,\n        validate: (v) =>\n          v === undefined ||\n          typeof v === 'string',\n        message: 'Icon must be a string if provided'\n      },\n      notifType: {\n        required: false,\n        validate: (v) =>\n          v === undefined ||\n          typeof v === 'string',\n        message: 'Notification type must be a string if provided'\n      },\n      notifInvokerId: {\n        required: false,\n        validate: (v) =>\n          v === undefined ||\n          (typeof v === 'string' && v.trim().length > 0),\n        message: 'Notification invoker ID must be a non-empty string if provided'\n      },\n      expireOn: {\n        required: false,\n        validate: (v) => {\n          // If expireOn is provided, validate it's a valid date string\n          if (v !== undefined) {\n            const expireDate = new Date(v);\n\n            return !isNaN(expireDate.getTime()) && expireDate > new Date();\n          }\n\n          return true;\n        },\n        message: 'Expiration date must be a valid future date if provided'\n      }\n    });\n\n    super(data);\n    this.authUser = data.authUser;\n    this.targetId = data.targetId;\n    this.targetType = data.targetType;\n    this.title = data.title;\n    this.body = data.body;\n    this.icon = data.icon;\n    this.notifType = data.notifType;\n    this.notifInvokerId = data.notifInvokerId;\n    this.viewed = data.viewed;\n    this.username = data.username;\n    this.email = data.email;\n    this.phone = data.phone;\n    this.phoneCode = data.phoneCode;\n    this.extraDetails = data.extraDetails;\n  }\n\n  /**\n   * Retrieves a paginated list of notifications\n   * @param {number} [offset=0] - The number of items to skip before starting to collect the result set\n   * @param {number} [limit=20] - The maximum number of items to return\n   * @param {string} [targetId] - The ID of the target to filter notifications for\n   * @returns {Promise<{count: number, dataArr: NotificationMain[]}>} Object containing count and array of notifications\n   * @throws {Error} If the API request fails\n   * @example\n   * // Get first 20 notifications\n   * const { count, dataArr } = await NotificationMain.getAll();\n   */\n  static async getAll(offset = 0, limit = 20, targetId?: string) {\n    let query = new URLSearchParams({\n      offset: offset.toString(),\n      limit: limit.toString()\n    }).toString();\n\n    if (targetId) {\n      query += `&targetId=${targetId}`;\n    }\n    const observer$ = NotificationClient\n      .ehttp.makeGet<IdataArrayResponse<Imainnotification>>(`${NotificationMain.baseUrl}?${query}`);\n    const notifications = await lastValueFrom(observer$);\n\n    return {\n      count: notifications.count,\n      dataArr: notifications.data.map(val => new NotificationMain(val))\n    };\n  }\n\n  /**\n   * Retrieves notifications based on filter criteria\n   * @param {IfilterProps} filter - The filter criteria to apply\n   * @returns {Promise<{count: number, dataArr: NotificationMain[]}>} Object containing count and filtered notifications\n   * @throws {Error} If the API request fails\n   * @example\n   * // Get unread notifications\n   * const { dataArr } = await NotificationMain.filterAll({\n   *   conditions: { viewed: false }\n   * });\n   */\n  static async filterAll(filter: IfilterProps) {\n    const observer$ = NotificationClient.ehttp\n      .makePost<IdataArrayResponse<Imainnotification>>(\n        `${NotificationMain.baseUrl}/filter`,\n        filter\n      );\n    const notifns = await lastValueFrom(observer$);\n\n    return {\n      count: notifns.count,\n      dataArr: notifns.data.map((val) => new NotificationMain(val))\n    };\n  }\n\n  /**\n   * Marks all notifications as read for the current user\n   * @param {string} [targetId] - The ID of the target to mark notifications for\n   * @returns {Promise<Isuccess>} Success status of the operation\n   * @throws {Error} If the API request fails\n   * @example\n   * await NotificationMain.markAllAsRead();\n   */\n  static markAllAsRead(targetId?: string): Promise<Isuccess> {\n    const observer$ = NotificationClient.ehttp\n      .makePost<Isuccess>(`${NotificationMain.baseUrl}/mark-all-read`, { targetId });\n\n    return lastValueFrom(observer$);\n  }\n\n  /**\n   * Gets the count of unviewed notifications for the current user\n   * @param {string} [targetId] - The ID of the target to get unviewed notifications for\n   * @returns {Promise<number>} Count of unviewed notifications\n   * @throws {Error} If the API request fails\n   * @example\n   * const unreadCount = await NotificationMain.getUnviewedLength();\n   */\n  static getUnviewedLength(targetId?: string): Promise<number> {\n    const observer$ = NotificationClient.ehttp\n      .makePost<number>(`${NotificationMain.baseUrl}/unviewed-length`, { targetId });\n\n    return lastValueFrom(observer$);\n  }\n\n  /**\n   * Marks the current notification as viewed\n   * @returns {Promise<NotificationMain>} The updated notification instance\n   * @throws {Error} If the update fails or notification doesn't exist\n   * @example\n   * const updatedNotification = await notificationInstance.updateViewed();\n   */\n  async updateViewed(): Promise<NotificationMain> {\n    const observer$ = NotificationClient.ehttp\n      .makePost<Imainnotification>(\n        `${NotificationMain.baseUrl}/update-viewed`,\n        { _id: this._id }\n      );\n\n    return new NotificationMain(await lastValueFrom(observer$));\n  }\n\n  /**\n   * Checks if the notification has expired\n   * @returns {boolean} True if the notification has expired, false otherwise\n   */\n  isExpired(): boolean {\n    return this.expireOn ? new Date(this.expireOn) < new Date() : false;\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;AAOA;;;ACaM,IAAO,qBAAP,MAAO,oBAAkB;;;;;;;;;;;EAc7B,YAAY,QAA8B;AACxC,QAAI,CAAC,UAAU,OAAO,WAAW,UAAU;AACzC,YAAM,IAAI,mBAAmB,+BAA+B;IAC9D;AAEA,mBAAe,MAAM,gCAAgC;AACrD,wBAAmB,OAAO,IAAI,gBAAgB,MAAM;EACtD;;;;;;;;;;;EAYA,WAAW,QAAK;AACd,QAAI,CAAC,oBAAmB,MAAM;AAC5B,YAAM,IAAI,mBAAmB;uEACoC;IACnE;AAEA,WAAO,oBAAmB;EAC5B;;;;ADhCI,IAAO,qBAAP,MAAO,4BAA2B,aAAY;;;;;EAmClD,YAAY,aAAyB;AACnC,UAAM,WAAW;AACjB,SAAK,SAAS,YAAY;AAC1B,SAAK,UAAU,YAAY;AAC3B,SAAK,YAAY,YAAY;AAC7B,SAAK,QAAQ,YAAY;AACzB,SAAK,YAAY,YAAY;AAC7B,SAAK,SAAS,YAAY;AAC1B,SAAK,aAAa,YAAY;AAC9B,SAAK,UAAU,YAAY;AAC3B,SAAK,aAAa,YAAY;EAChC;;;;;;;;;;;;EAaA,OAAa,OAAO,QAAgB,OAAa;;AAC/C,YAAM,QAAQ,IAAI,gBAAgB;QAChC,QAAQ,OAAO,SAAQ;QACvB,OAAO,MAAM,SAAQ;OACtB,EAAE,SAAQ;AACX,YAAM,YAAY,mBAAmB,MAClC,QAA0C,GAAG,oBAAmB,OAAO,IAAI,KAAK,EAAE;AACrF,YAAM,WAAW,MAAM,cAAc,SAAS;AAE9C,aAAO;QACL,OAAO,SAAS;QAChB,SAAS,SAAS,KAAK,IAAI,SAAO,IAAI,oBAAmB,GAAG,CAAC;;IAEjE;;;;;;;;;;;;;EAaA,OAAa,UAAU,QAAoB;;AACzC,YAAM,YAAY,mBAAmB,MAClC,SACC,GAAG,oBAAmB,OAAO,WAC7B,EAAE,OAAM,CAAE;AAEd,YAAM,WAAW,MAAM,cAAc,SAAS;AAE9C,aAAO;QACL,OAAO,SAAS;QAChB,SAAS,SAAS,KAAK,IAAI,SAAO,IAAI,oBAAmB,GAAG,CAAC;;IAEjE;;;;;;;;;;EAUA,OAAa,OAAO,YAAkB;;AACpC,YAAM,YAAY,mBAAmB,MAClC,QAAsB,GAAG,oBAAmB,OAAO,IAAI,UAAU,EAAE;AACtE,YAAM,WAAW,MAAM,cAAc,SAAS;AAE9C,aAAO,IAAI,oBAAmB,QAAQ;IACxC;;;;;;;;;;;;;;;;EAgBA,OAAa,IAAI,SACuE;;AACtF,YAAM,YAAY,mBAAmB,MAClC,SAAuB,GAAG,oBAAmB,OAAO,IAAI,OAAO;AAElE,aAAO,IAAI,oBAAmB,MAAM,cAAc,SAAS,CAAC;IAC9D;;;;;;;;;;;;EAYM,OAAO,SACoF;;AAC/F,YAAM,YAAY,mBAAmB,MAClC,QAAsB,GAAG,oBAAmB,OAAO,IAAI,KAAK,GAAG,IAAI,OAAO;AAE7E,aAAO,IAAI,oBAAmB,MAAM,cAAc,SAAS,CAAC;IAC9D;;;;;;;;;;;;EAYM,SAAM;;AACV,YAAM,YAAY,mBAAmB,MAClC,WAAsC,GAAG,oBAAmB,OAAO,IAAI,KAAK,GAAG,EAAE;AACpF,YAAM,WAAW,MAAM,cAAc,SAAS;AAE9C,aAAO;IACT;;;;;;EAMA,YAAS;AACP,WAAO,KAAK,YAAY,IAAI,KAAK,KAAK,SAAS,IAAI,oBAAI,KAAI,IAAK;EAClE;;;;;EAMA,eAAY;AACV,QAAI,CAAC,KAAK,WAAW,KAAK,UAAS,GAAI;AACrC,aAAO;IACN;AAEH,WAAO,CAAC,KAAK,cAAc,KAAK,cAAc,KAAK,KAAK;EAC1D;;AA7LwB,mBAAA,UAAU;;;AE1BpC;AAoBM,IAAO,eAAP,MAAO,cAAY;;;;;;EA0CvB,YAAY,cAA2B;AACrC,UAAM,gBAAgB,CAAC,SAAS,OAAO,QAAQ,KAAK;AAEpD,iBAAa,cAAc;MACzB,KAAK;QACH,UAAU,CAAC,MACT,OAAO,MAAM,YACb,EAAE,KAAI,EAAG,SAAS;QACpB,SAAS;;MAEX,SAAS;QACP,UAAU;QACV,UAAU,CAAC,MACT,MAAM,UACL,OAAO,MAAM,YAAY,EAAE,KAAI,EAAG,SAAS;QAC9C,SAAS;;MAEX,YAAY;QACV,UAAU;QACV,UAAU,CAAC,MACT,MAAM,UACN,OAAO,MAAM;QACf,SAAS;;MAEX,OAAO;QACL,UAAU,CAAC,MACT,MAAM,QAAQ,CAAC,KACf,EAAE,MAAM,aACN,OAAO,YAAY,YACnB,YAAY,IAAI;QACpB,SAAS;;MAEX,WAAW;QACT,UAAU;QACV,UAAU,CAAC,MACT,MAAM,UACL,OAAO,MAAM,YAAY,KAAK;QACjC,SAAS;;MAEX,UAAU;QACR,UAAU;QACV,UAAU,CAAC,MACT,MAAM,UACL,MAAM,QAAQ,CAAC,KACd,EAAE,MAAM,aACN,OAAO,YAAY,YACrB,cAAc,SAAS,OAAO,CAAC;QACnC,SAAS,6DAA6D,cAAc,KAAK,IAAI,CAAC;;MAEhG,UAAU;QACR,UAAU;QACV,UAAU,CAAC,MACT,MAAM,UACN,OAAO,MAAM;QACf,SAAS;;MAEX,UAAU;QACR,UAAU;QACV,UAAU,CAAC,MACT,MAAM,UACN,OAAO,MAAM;QACf,SAAS;;MAEX,UAAU;QACR,UAAU;QACV,UAAU,CAAC,MACT,MAAM,UACN,OAAO,MAAM;QACf,SAAS;;KAEZ;AAED,SAAK,MAAM,aAAa;AACxB,SAAK,WAAW,aAAa;AAC7B,SAAK,UAAU,aAAa;AAC5B,SAAK,aAAa,aAAa;AAC/B,SAAK,QAAQ,aAAa;AAC1B,SAAK,YAAY,aAAa;AAC9B,SAAK,WAAW,aAAa;AAC7B,SAAK,WAAW,aAAa;AAC7B,SAAK,WAAW,aAAa;AAC7B,SAAK,WAAW,aAAa;AAC7B,SAAK,WAAW,aAAa;EAC/B;;;;;;;;;;;EAYA,OAAa,OAAO,QAAgB,OAAa;;AAC/C,YAAM,QAAQ,IAAI,gBAAgB;QAChC,QAAQ,OAAO,SAAQ;QACvB,OAAO,MAAM,SAAQ;OACtB,EAAE,SAAQ;AACX,YAAM,YAAY,mBAAmB,MAClC,QAAyB,GAAG,cAAa,OAAO,IAAI,KAAK,EAAE;AAC9D,YAAM,WAAW,MAAM,cAAc,SAAS;AAE9C,aAAO,SAAS,IAAI,UAAQ,IAAI,cAAa,IAAI,CAAC;IACpD;;;;;;;;;;;;;EAaA,OAAa,UAAU,QAAoB;;AACzC,YAAM,YAAY,mBAAmB,MAClC,SAA0B,GAAG,cAAa,OAAO,WAAW,EAAE,OAAM,CAAE;AACzE,YAAM,WAAW,MAAM,cAAc,SAAS;AAE9C,aAAO,SAAS,IAAI,UAAQ,IAAI,cAAa,IAAI,CAAC;IACpD;;;;;;;;;;EAUA,OAAa,OAAO,YAAkB;;AACpC,YAAM,YAAY,mBAAmB,MAClC,QAAuB,GAAG,cAAa,OAAO,IAAI,UAAU,EAAE;AACjE,YAAM,WAAW,MAAM,cAAc,SAAS;AAE9C,aAAO,IAAI,cAAa,QAAQ;IAClC;;;;;;;;;;;;;;;EAeA,OAAa,IAAI,SAAmC;;AAClD,YAAM,YAAY,mBAAmB,MAClC,SAAwB,GAAG,cAAa,OAAO,IAAI,OAAO;AAE7D,aAAO,IAAI,cAAa,MAAM,cAAc,SAAS,CAAC;IACxD;;;;;;;;;;;;;EAaM,OAAO,SAA6B;;AACxC,YAAM,YAAY,mBAAmB,MAClC,QAAuB,GAAG,cAAa,OAAO,IAAI,KAAK,GAAG,IAAI,OAAO;AAExE,aAAO,IAAI,cAAa,MAAM,cAAc,SAAS,CAAC;IACxD;;;AA1NgB,aAAA,UAAU;;;ACrB5B;AAiBM,IAAO,mBAAP,MAAO,0BAAyB,aAAY;;;;;;EAsDhD,YAAY,MAAuB;AACjC,iBAAa,MAAM;MACjB,OAAO;QACL,UAAU,CAAC,MACT,OAAO,MAAM,YACb,EAAE,KAAI,EAAG,SAAS;QACpB,SAAS;;MAEX,MAAM;QACJ,UAAU,CAAC,MACT,OAAO,MAAM,YACb,EAAE,KAAI,EAAG,SAAS;QACpB,SAAS;;MAEX,MAAM;QACJ,UAAU;QACV,UAAU,CAAC,MACT,MAAM,UACN,OAAO,MAAM;QACf,SAAS;;MAEX,WAAW;QACT,UAAU;QACV,UAAU,CAAC,MACT,MAAM,UACN,OAAO,MAAM;QACf,SAAS;;MAEX,gBAAgB;QACd,UAAU;QACV,UAAU,CAAC,MACT,MAAM,UACL,OAAO,MAAM,YAAY,EAAE,KAAI,EAAG,SAAS;QAC9C,SAAS;;MAEX,UAAU;QACR,UAAU;QACV,UAAU,CAAC,MAAK;AAEd,cAAI,MAAM,QAAW;AACnB,kBAAM,aAAa,IAAI,KAAK,CAAC;AAE7B,mBAAO,CAAC,MAAM,WAAW,QAAO,CAAE,KAAK,aAAa,oBAAI,KAAI;UAC9D;AAEA,iBAAO;QACT;QACA,SAAS;;KAEZ;AAED,UAAM,IAAI;AACV,SAAK,WAAW,KAAK;AACrB,SAAK,WAAW,KAAK;AACrB,SAAK,aAAa,KAAK;AACvB,SAAK,QAAQ,KAAK;AAClB,SAAK,OAAO,KAAK;AACjB,SAAK,OAAO,KAAK;AACjB,SAAK,YAAY,KAAK;AACtB,SAAK,iBAAiB,KAAK;AAC3B,SAAK,SAAS,KAAK;AACnB,SAAK,WAAW,KAAK;AACrB,SAAK,QAAQ,KAAK;AAClB,SAAK,QAAQ,KAAK;AAClB,SAAK,YAAY,KAAK;AACtB,SAAK,eAAe,KAAK;EAC3B;;;;;;;;;;;;EAaA,OAAa,OAAO,SAAS,GAAG,QAAQ,IAAI,UAAiB;;AAC3D,UAAI,QAAQ,IAAI,gBAAgB;QAC9B,QAAQ,OAAO,SAAQ;QACvB,OAAO,MAAM,SAAQ;OACtB,EAAE,SAAQ;AAEX,UAAI,UAAU;AACZ,iBAAS,aAAa,QAAQ;MAChC;AACA,YAAM,YAAY,mBACf,MAAM,QAA+C,GAAG,kBAAiB,OAAO,IAAI,KAAK,EAAE;AAC9F,YAAM,gBAAgB,MAAM,cAAc,SAAS;AAEnD,aAAO;QACL,OAAO,cAAc;QACrB,SAAS,cAAc,KAAK,IAAI,SAAO,IAAI,kBAAiB,GAAG,CAAC;;IAEpE;;;;;;;;;;;;;EAaA,OAAa,UAAU,QAAoB;;AACzC,YAAM,YAAY,mBAAmB,MAClC,SACC,GAAG,kBAAiB,OAAO,WAC3B,MAAM;AAEV,YAAM,UAAU,MAAM,cAAc,SAAS;AAE7C,aAAO;QACL,OAAO,QAAQ;QACf,SAAS,QAAQ,KAAK,IAAI,CAAC,QAAQ,IAAI,kBAAiB,GAAG,CAAC;;IAEhE;;;;;;;;;;EAUA,OAAO,cAAc,UAAiB;AACpC,UAAM,YAAY,mBAAmB,MAClC,SAAmB,GAAG,kBAAiB,OAAO,kBAAkB,EAAE,SAAQ,CAAE;AAE/E,WAAO,cAAc,SAAS;EAChC;;;;;;;;;EAUA,OAAO,kBAAkB,UAAiB;AACxC,UAAM,YAAY,mBAAmB,MAClC,SAAiB,GAAG,kBAAiB,OAAO,oBAAoB,EAAE,SAAQ,CAAE;AAE/E,WAAO,cAAc,SAAS;EAChC;;;;;;;;EASM,eAAY;;AAChB,YAAM,YAAY,mBAAmB,MAClC,SACC,GAAG,kBAAiB,OAAO,kBAC3B,EAAE,KAAK,KAAK,IAAG,CAAE;AAGrB,aAAO,IAAI,kBAAiB,MAAM,cAAc,SAAS,CAAC;IAC5D;;;;;;EAMA,YAAS;AACP,WAAO,KAAK,WAAW,IAAI,KAAK,KAAK,QAAQ,IAAI,oBAAI,KAAI,IAAK;EAChE;;AApOgB,iBAAA,UAAU;",
  "names": []
}
